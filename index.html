<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¤¾äº¤åª’ä½“å‘å¸ƒæ—¥å†</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@100;200;300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Work Sans', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #f8f9fa;
        }
        .calendar-cell {
            border: 1px solid #e5e7eb;
            transition: all 0.2s ease;
        }
        .calendar-cell:hover {
            border-color: #d1d5db;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .today-cell {
            background-color: #86efac !important;
            border-color: #22c55e;
        }
        .past-cell {
            background-color: #f9fafb;
            color: #9ca3af;
        }
        .aspect-9-16 {
            aspect-ratio: 9 / 16;
        }
        .media-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .media-container img,
        .media-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
        }
        .nav-button {
            min-width: 48px;
            min-height: 48px;
            flex-shrink: 0;
        }
        .calendar-video {
            transition: opacity 0.3s ease;
        }
        .calendar-video:hover {
            opacity: 0.9;
        }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2.39.0/dist/umd/supabase.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Supabaseé…ç½® - å·²é…ç½®æ‚¨çš„é¡¹ç›®å‡­æ®
        const SUPABASE_URL = 'https://twmzmxuhddwdpylziabm.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR3bXpteHVoZGR3ZHB5bHppYWJtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM5MDM2NjYsImV4cCI6MjA2OTQ3OTY2Nn0._EBOw9cp7b9kN0_76STtY4D99deb8OLyQH4IEJ5l8AM';
        
        // åˆå§‹åŒ–Supabaseå®¢æˆ·ç«¯
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // æ£€æŸ¥Supabaseæ˜¯å¦é…ç½®æ­£ç¡®
        const isSupabaseConfigured = SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY';
        
        // è°ƒè¯•æ¨¡å¼å¼€å…³ - åœ¨ç”Ÿäº§ç¯å¢ƒä¸­å¯ä»¥è®¾ä¸ºfalse
        const DEBUG_MODE = true;
        
        // ğŸ“¦ æ™ºèƒ½å­˜å‚¨ç­–ç•¥é…ç½®
        const STORAGE_CONFIG = {
            // æ–‡ä»¶å¤§å°é™åˆ¶ï¼ˆå­—èŠ‚ï¼‰
            MAX_LOCAL_FILE_SIZE: 50 * 1024 * 1024,  // 50MBæœ¬åœ°å­˜å‚¨é™åˆ¶
            MAX_CLOUD_FILE_SIZE: 100 * 1024 * 1024, // 100MBäº‘ç«¯å­˜å‚¨é™åˆ¶
            
            // å‹ç¼©é…ç½®
            IMAGE_QUALITY: 0.8,                     // å›¾ç‰‡å‹ç¼©è´¨é‡
            VIDEO_QUALITY: 0.7,                     // è§†é¢‘å‹ç¼©è´¨é‡
            THUMBNAIL_SIZE: 200,                    // ç¼©ç•¥å›¾å°ºå¯¸
            
            // å›¾ç‰‡è‡ªåŠ¨å‹ç¼©é…ç½®
            IMAGE_COMPRESSION: {
                autoCompress: true,                  // å¯ç”¨å›¾ç‰‡è‡ªåŠ¨å‹ç¼©
                maxSizeMB: 5,                       // è‡ªåŠ¨å‹ç¼©é˜ˆå€¼ï¼š5MB
                targetSizeMB: 1,                    // ç›®æ ‡å¤§å°ï¼š1MB
                maxWidth: 1920,                     // æœ€å¤§å®½åº¦
                maxHeight: 1920,                    // æœ€å¤§é«˜åº¦
                quality: 0.85,                      // å‹ç¼©è´¨é‡
                progressive: true,                  // æ¸è¿›å¼JPEG
                format: 'image/jpeg'                // è¾“å‡ºæ ¼å¼
            },
            
            // è§†é¢‘å‹ç¼©é…ç½®
            VIDEO_COMPRESSION: {
                maxWidth: 1280,                     // è§†é¢‘æœ€å¤§å®½åº¦
                maxHeight: 720,                     // è§†é¢‘æœ€å¤§é«˜åº¦
                bitrate: 1000000,                   // ç›®æ ‡ç ç‡ 1Mbps
                frameRate: 24,                      // ç›®æ ‡å¸§ç‡
                targetSizeMB: 15,                   // ç›®æ ‡æ–‡ä»¶å¤§å°
                skipCompressionSizeMB: 3,           // è·³è¿‡å‹ç¼©çš„æœ€å°å¤§å°
                quality: 0.8                        // å‹ç¼©è´¨é‡
            },
            
            // å­˜å‚¨ç­–ç•¥
            AUTO_CLOUD_SYNC: true,                  // è‡ªåŠ¨äº‘ç«¯åŒæ­¥
            PREFER_LOCAL: true,                     // ä¼˜å…ˆæœ¬åœ°å­˜å‚¨
            ENABLE_COMPRESSION: true,               // å¯ç”¨å‹ç¼©
            AUTO_VIDEO_COMPRESSION: true,           // è‡ªåŠ¨è§†é¢‘å‹ç¼©
            
            // åŒæ­¥é—´éš”
            SYNC_DELAY: 2000,                       // åŒæ­¥å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
        };
        
        // ğŸ“¦ æ™ºèƒ½å­˜å‚¨ç®¡ç†å™¨
        class SmartStorageManager {
            constructor() {
                this.storageStats = {
                    localSize: 0,
                    cloudSize: 0,
                    totalFiles: 0,
                    syncStatus: 'idle' // idle, syncing, error, success
                };
            }

            // ğŸ” æ£€æµ‹æ–‡ä»¶å­˜å‚¨ç­–ç•¥
            determineStorageStrategy(file) {
                const fileSize = file.size;
                const fileSizeMB = fileSize / (1024 * 1024);
                const isLargeFile = fileSize > STORAGE_CONFIG.MAX_LOCAL_FILE_SIZE;
                const isHugeFile = fileSize > STORAGE_CONFIG.MAX_CLOUD_FILE_SIZE;
                const isVideo = file.type.startsWith('video/');
                const isImage = file.type.startsWith('image/');
                
                // ğŸ–¼ï¸ å›¾ç‰‡è‡ªåŠ¨å‹ç¼©ç­–ç•¥ï¼šè¶…è¿‡5MBçš„å›¾ç‰‡è‡ªåŠ¨å‹ç¼©åˆ°1MB
                if (isImage && STORAGE_CONFIG.IMAGE_COMPRESSION.autoCompress && 
                    fileSizeMB > STORAGE_CONFIG.IMAGE_COMPRESSION.maxSizeMB) {
                    return {
                        storeLocal: true,         // å‹ç¼©åæœ¬åœ°å­˜å‚¨
                        storeCloud: STORAGE_CONFIG.AUTO_CLOUD_SYNC,
                        needsCompression: true,   // éœ€è¦å‹ç¼©
                        createThumbnail: true,    // ç”Ÿæˆç¼©ç•¥å›¾
                        autoImageCompress: true,  // æ ‡è®°ä¸ºå›¾ç‰‡è‡ªåŠ¨å‹ç¼©
                        targetSize: STORAGE_CONFIG.IMAGE_COMPRESSION.targetSizeMB
                    };
                }
                
                // ğŸ¥ è§†é¢‘å‹ç¼©ç­–ç•¥ï¼šå‹ç¼©åç›´æ¥ä¸Šä¼ äº‘ç«¯
                if (isVideo && isLargeFile && STORAGE_CONFIG.AUTO_VIDEO_COMPRESSION) {
                    return {
                        storeLocal: false,        // ä¸å­˜å‚¨åœ¨æœ¬åœ°
                        storeCloud: true,         // ç›´æ¥ä¸Šä¼ äº‘ç«¯
                        needsCompression: true,   // éœ€è¦å‹ç¼©
                        createThumbnail: true,    // ç”Ÿæˆç¼©ç•¥å›¾
                        uploadCompressed: true,   // æ ‡è®°ä¸ºå‹ç¼©åä¸Šä¼ 
                        localThumbnailOnly: true  // æœ¬åœ°åªä¿å­˜ç¼©ç•¥å›¾
                    };
                }
                
                // ğŸ¯ å¸¸è§„æ–‡ä»¶å­˜å‚¨ç­–ç•¥
                const needsCompression = isLargeFile && STORAGE_CONFIG.ENABLE_COMPRESSION;
                return {
                    storeLocal: !isHugeFile,  // å…¶ä»–æ–‡ä»¶çš„æœ¬åœ°å­˜å‚¨ç­–ç•¥
                    storeCloud: STORAGE_CONFIG.AUTO_CLOUD_SYNC && !isHugeFile,
                    needsCompression: needsCompression,
                    createThumbnail: isVideo || isLargeFile
                };
            }

            // ğŸ“Š è®¡ç®—æœ¬åœ°å­˜å‚¨ä½¿ç”¨é‡
            calculateLocalStorageSize() {
                try {
                    const data = localStorage.getItem('socialMediaCalendar');
                    return data ? new Blob([data]).size : 0;
                } catch (error) {
                    console.warn('æ— æ³•è®¡ç®—æœ¬åœ°å­˜å‚¨å¤§å°:', error);
                    return 0;
                }
            }

            // ğŸ’¾ æ™ºèƒ½æ–‡ä»¶å¤„ç†
            async processFile(file) {
                const strategy = this.determineStorageStrategy(file);
                console.log(`ğŸ“¦ æ–‡ä»¶ ${file.name} å­˜å‚¨ç­–ç•¥:`, strategy);

                let result = {
                    type: file.type.startsWith('image/') ? 'image' : 'video',
                    name: file.name,
                    size: file.size,
                    file: file,
                    storageStrategy: strategy
                };

                try {
                    // 1. ç”Ÿæˆç¼©ç•¥å›¾ï¼ˆå¦‚æœéœ€è¦ï¼‰
                    if (strategy.createThumbnail) {
                        if (file.type.startsWith('video/')) {
                            result.thumbnail = await this.createVideoThumbnail(file);
                        } else {
                            result.thumbnail = await this.createImageThumbnail(file);
                        }
                    }

                    // 2. å¤„ç†å­˜å‚¨ç­–ç•¥
                    if (strategy.uploadCompressed && strategy.needsCompression) {
                        // ğŸ¥ å‹ç¼©è§†é¢‘ç›´ä¼ äº‘ç«¯ç­–ç•¥
                        const startTime = Date.now();
                        console.log(`ğŸš€ è§†é¢‘å°†å‹ç¼©åç›´æ¥ä¸Šä¼ äº‘ç«¯: ${file.name}`);
                        
                        result.compressedBlob = await this.compressFileToBlob(file);
                        result.isCompressed = true;
                        result.compressionTime = Date.now() - startTime;
                        result.compressedSize = (result.compressedBlob.size / 1024 / 1024).toFixed(1) + 'MB';
                        
                        // æœ¬åœ°åªä¿å­˜ç¼©ç•¥å›¾ï¼Œç”¨äºé¢„è§ˆ
                        result.dataUrl = result.thumbnail;
                        result.originalDataUrl = null; // ä¸ä¿å­˜åŸè§†é¢‘åœ¨æœ¬åœ°
                        result.needsCloudUpload = true;
                        result.uploadCompressed = true;
                        
                        console.log(`ğŸ“¤ å‹ç¼©å®Œæˆï¼Œå‡†å¤‡ä¸Šä¼ : ${file.name} (${result.compressedSize})`);
                        
                    } else if (strategy.storeLocal) {
                        // æœ¬åœ°å­˜å‚¨ç­–ç•¥
                        if (strategy.needsCompression || strategy.autoImageCompress) {
                            const startTime = Date.now();
                            
                            // ğŸ¯ ä½¿ç”¨æ™ºèƒ½å‹ç¼©ï¼ˆæ”¯æŒå›¾ç‰‡ç›®æ ‡å¤§å°å‹ç¼©ï¼‰
                            result.dataUrl = await this.smartCompressFile(file, strategy);
                            result.isCompressed = true;
                            result.compressionTime = Date.now() - startTime;
                            
                            // ä¼°ç®—å‹ç¼©åçš„å¤§å°
                            if (result.dataUrl) {
                                const compressedSize = this.estimateDataUrlSize(result.dataUrl);
                                result.compressedSize = (compressedSize / 1024 / 1024).toFixed(1) + 'MB';
                                
                                // ç‰¹æ®Šæ ‡è®°æ™ºèƒ½å›¾ç‰‡å‹ç¼©
                                if (strategy.autoImageCompress) {
                                    result.autoImageCompressed = true;
                                    result.targetSizeMB = strategy.targetSize;
                                    const compressionRatio = ((1 - compressedSize / file.size) * 100).toFixed(1);
                                    console.log(`ğŸ“¸ æ™ºèƒ½å›¾ç‰‡å‹ç¼©: ${file.name}, å‹ç¼©ç‡: ${compressionRatio}%`);
                                }
                            }
                        } else {
                            result.dataUrl = await this.fileToDataUrl(file);
                            result.isCompressed = false;
                        }
                        result.originalDataUrl = result.dataUrl;
                    }

                    // 3. æ ‡è®°äº‘ç«¯å­˜å‚¨éœ€æ±‚
                    if (strategy.storeCloud) {
                        result.needsCloudUpload = true;
                    }

                    console.log(`âœ… æ–‡ä»¶ ${file.name} å¤„ç†å®Œæˆ`);
                    return result;

                } catch (error) {
                    console.error(`âŒ æ–‡ä»¶ ${file.name} å¤„ç†å¤±è´¥:`, error);
                    
                    // æ ¹æ®é”™è¯¯ç±»å‹æä¾›æ›´å…·ä½“çš„é”™è¯¯ä¿¡æ¯
                    let errorMessage = error.message;
                    if (error.name === 'QuotaExceededError') {
                        errorMessage = 'æ–‡ä»¶è¿‡å¤§ï¼Œè¶…å‡ºå­˜å‚¨é™åˆ¶';
                    } else if (error.message.includes('network')) {
                        errorMessage = 'ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥';
                    } else if (error.message.includes('format')) {
                        errorMessage = 'æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ';
                    } else if (error.message.includes('canvas')) {
                        errorMessage = 'å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œå¯èƒ½æ–‡ä»¶æŸå';
                    }
                    
                    // è¿”å›åŸºç¡€ä¿¡æ¯ï¼Œå³ä½¿å¤„ç†å¤±è´¥
                    return {
                        ...result,
                        error: errorMessage,
                        dataUrl: result.thumbnail || null,
                        hasError: true
                    };
                }
            }

            // ğŸ–¼ï¸ åˆ›å»ºå›¾ç‰‡ç¼©ç•¥å›¾
            async createImageThumbnail(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    img.onload = () => {
                        const size = STORAGE_CONFIG.THUMBNAIL_SIZE;
                        canvas.width = size;
                        canvas.height = size;
                        
                        // å±…ä¸­è£å‰ª
                        const minDim = Math.min(img.width, img.height);
                        const scale = size / minDim;
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        const x = (size - scaledWidth) / 2;
                        const y = (size - scaledHeight) / 2;
                        
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                        resolve(canvas.toDataURL('image/jpeg', 0.8));
                    };
                    
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            // ğŸ¥ åˆ›å»ºè§†é¢‘ç¼©ç•¥å›¾
            async createVideoThumbnail(file) {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    video.addEventListener('loadeddata', () => {
                        try {
                            const size = STORAGE_CONFIG.THUMBNAIL_SIZE;
                            canvas.width = size;
                            canvas.height = size;
                            
                            // å±…ä¸­è£å‰ª
                            const scale = size / Math.min(video.videoWidth, video.videoHeight);
                            const scaledWidth = video.videoWidth * scale;
                            const scaledHeight = video.videoHeight * scale;
                            const x = (size - scaledWidth) / 2;
                            const y = (size - scaledHeight) / 2;
                            
                            ctx.drawImage(video, x, y, scaledWidth, scaledHeight);
                            resolve(canvas.toDataURL('image/jpeg', 0.8));
                        } catch (error) {
                            reject(error);
                        }
                    });

                    video.addEventListener('error', reject);
                    video.src = URL.createObjectURL(file);
                    video.currentTime = 1; // è·å–ç¬¬1ç§’çš„ç”»é¢
                });
            }

            // ğŸ—œï¸ å‹ç¼©æ–‡ä»¶
            async compressFile(file) {
                if (file.type.startsWith('image/')) {
                    return this.compressImage(file);
                } else if (file.type.startsWith('video/')) {
                    return this.compressVideo(file);
                }
                return this.fileToDataUrl(file);
            }

            // ğŸ¯ æ™ºèƒ½å‹ç¼©æ–‡ä»¶ï¼ˆæ ¹æ®ç­–ç•¥é€‰æ‹©å‹ç¼©æ–¹å¼ï¼‰
            async smartCompressFile(file, strategy) {
                if (strategy.autoImageCompress && file.type.startsWith('image/')) {
                    // ä½¿ç”¨æ™ºèƒ½å›¾ç‰‡å‹ç¼©åˆ°ç›®æ ‡å¤§å°
                    return this.compressImageToTargetSize(file, strategy.targetSize);
                } else if (file.type.startsWith('image/')) {
                    return this.compressImage(file);
                } else if (file.type.startsWith('video/')) {
                    return this.compressVideo(file);
                }
                return this.fileToDataUrl(file);
            }

            // ğŸ—œï¸ å‹ç¼©æ–‡ä»¶åˆ°Blobï¼ˆç”¨äºäº‘ç«¯ä¸Šä¼ ï¼‰
            async compressFileToBlob(file) {
                if (file.type.startsWith('image/')) {
                    const dataUrl = await this.compressImage(file);
                    return this.dataUrlToBlob(dataUrl);
                } else if (file.type.startsWith('video/')) {
                    return this.compressVideoToBlob(file);
                }
                return file;
            }

            // ğŸ¥ å‹ç¼©è§†é¢‘
            async compressVideo(file) {
                console.log(`ğŸ¬ å¼€å§‹å‹ç¼©è§†é¢‘: ${file.name}, åŸå§‹å¤§å°: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
                
                // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨å‹ç¼©
                if (!STORAGE_CONFIG.AUTO_VIDEO_COMPRESSION) {
                    console.log('ğŸ”§ è‡ªåŠ¨è§†é¢‘å‹ç¼©å·²ç¦ç”¨');
                    return this.fileToDataUrl(file);
                }
                
                // ä½¿ç”¨é…ç½®çš„å‹ç¼©å‚æ•°
                const compressionConfig = STORAGE_CONFIG.VIDEO_COMPRESSION;

                // å¦‚æœæ–‡ä»¶å·²ç»å¾ˆå°ï¼Œç›´æ¥è¿”å›
                if (file.size < compressionConfig.skipCompressionSizeMB * 1024 * 1024) {
                    console.log('ğŸ“ æ–‡ä»¶å·²ç»å¾ˆå°ï¼Œè·³è¿‡å‹ç¼©');
                    return this.fileToDataUrl(file);
                }

                try {
                    // ä½¿ç”¨MediaRecorder APIè¿›è¡Œè§†é¢‘å‹ç¼©
                    const compressedBlob = await this.compressVideoWithMediaRecorder(file, compressionConfig);
                    
                    if (compressedBlob && compressedBlob.size < file.size) {
                        console.log(`âœ… è§†é¢‘å‹ç¼©æˆåŠŸ: ${file.name}, å‹ç¼©åå¤§å°: ${(compressedBlob.size / 1024 / 1024).toFixed(2)} MB`);
                        return this.blobToDataUrl(compressedBlob);
                    } else {
                        console.log('ğŸ”„ MediaRecorderå‹ç¼©æ•ˆæœä¸ä½³ï¼Œå°è¯•å…¶ä»–æ–¹æ¡ˆ...');
                        return this.compressVideoFallback(file, compressionConfig);
                    }
                } catch (error) {
                    console.warn('MediaRecorderå‹ç¼©å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ:', error);
                    return this.compressVideoFallback(file, compressionConfig);
                }
            }

            // ğŸ“¹ ä½¿ç”¨MediaRecorderå‹ç¼©è§†é¢‘
            async compressVideoWithMediaRecorder(file, config) {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    video.addEventListener('loadedmetadata', () => {
                        const { videoWidth, videoHeight } = video;
                        
                        // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
                        let targetWidth = videoWidth;
                        let targetHeight = videoHeight;
                        
                        if (videoWidth > config.maxWidth || videoHeight > config.maxHeight) {
                            const aspectRatio = videoWidth / videoHeight;
                            if (aspectRatio > 1) {
                                targetWidth = config.maxWidth;
                                targetHeight = config.maxWidth / aspectRatio;
                            } else {
                                targetHeight = config.maxHeight;
                                targetWidth = config.maxHeight * aspectRatio;
                            }
                        }
                        
                        canvas.width = Math.floor(targetWidth);
                        canvas.height = Math.floor(targetHeight);
                        
                        console.log(`ğŸ”§ å‹ç¼©å°ºå¯¸: ${canvas.width}x${canvas.height}`);
                        
                        // åˆ›å»ºCanvasæµ
                        const stream = canvas.captureStream(24); // 24fps
                        
                        // é…ç½®MediaRecorder
                        const options = {
                            mimeType: 'video/webm;codecs=vp9',
                            videoBitsPerSecond: config.bitrate
                        };
                        
                        // æ£€æŸ¥æ”¯æŒçš„ç¼–ç æ ¼å¼
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            options.mimeType = 'video/webm;codecs=vp8';
                            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                                options.mimeType = 'video/webm';
                                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                                    reject(new Error('ä¸æ”¯æŒè§†é¢‘å‹ç¼©æ ¼å¼'));
                                    return;
                                }
                            }
                        }
                        
                        const mediaRecorder = new MediaRecorder(stream, options);
                        const chunks = [];
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                chunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const compressedBlob = new Blob(chunks, { type: options.mimeType });
                            resolve(compressedBlob);
                        };
                        
                        mediaRecorder.onerror = reject;
                        
                        // å¼€å§‹å½•åˆ¶
                        mediaRecorder.start();
                        
                        // æ’­æ”¾åŸè§†é¢‘å¹¶ç»˜åˆ¶åˆ°Canvas
                        video.addEventListener('play', () => {
                            const drawFrame = () => {
                                if (!video.paused && !video.ended) {
                                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                    requestAnimationFrame(drawFrame);
                                } else {
                                    mediaRecorder.stop();
                                    stream.getTracks().forEach(track => track.stop());
                                }
                            };
                            drawFrame();
                        });
                        
                        video.addEventListener('ended', () => {
                            mediaRecorder.stop();
                            stream.getTracks().forEach(track => track.stop());
                        });
                        
                        video.play();
                    });
                    
                    video.addEventListener('error', reject);
                    video.src = URL.createObjectURL(file);
                    video.load();
                });
            }

            // ğŸ”„ å¤‡ç”¨è§†é¢‘å‹ç¼©æ–¹æ¡ˆ
            async compressVideoFallback(file, config) {
                console.log('ğŸ”„ ä½¿ç”¨å¤‡ç”¨å‹ç¼©æ–¹æ¡ˆ...');
                
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    video.addEventListener('loadedmetadata', async () => {
                        try {
                            const { videoWidth, videoHeight, duration } = video;
                            
                            // è®¡ç®—å‹ç¼©å°ºå¯¸
                            let targetWidth = Math.min(videoWidth, config.maxWidth);
                            let targetHeight = Math.min(videoHeight, config.maxHeight);
                            
                            const aspectRatio = videoWidth / videoHeight;
                            if (targetWidth / targetHeight !== aspectRatio) {
                                if (targetWidth / aspectRatio <= config.maxHeight) {
                                    targetHeight = targetWidth / aspectRatio;
                                } else {
                                    targetWidth = targetHeight * aspectRatio;
                                }
                            }
                            
                            canvas.width = Math.floor(targetWidth);
                            canvas.height = Math.floor(targetHeight);
                            
                            // å¦‚æœè§†é¢‘å¤ªå¤§ï¼Œè¿”å›é«˜è´¨é‡å°é¢å›¾
                            if (file.size > config.targetSizeMB * 1024 * 1024) {
                                console.log('âš ï¸ è§†é¢‘æ–‡ä»¶è¿‡å¤§ï¼Œç”Ÿæˆé«˜è´¨é‡å°é¢');
                                video.currentTime = Math.min(1, duration * 0.1);
                                
                                video.addEventListener('seeked', () => {
                                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                    const coverDataUrl = canvas.toDataURL('image/jpeg', config.quality);
                                    resolve(coverDataUrl);
                                }, { once: true });
                            } else {
                                // æ–‡ä»¶å¤§å°å¯æ¥å—ï¼Œè¿”å›åŸè§†é¢‘
                                const originalDataUrl = await this.fileToDataUrl(file);
                                console.log(`âœ… ä¿æŒåŸè§†é¢‘è´¨é‡: ${file.name}`);
                                resolve(originalDataUrl);
                            }
                        } catch (error) {
                            reject(error);
                        }
                    });
                    
                    video.addEventListener('error', reject);
                    video.src = URL.createObjectURL(file);
                    video.load();
                });
            }

            // ğŸ¥ å‹ç¼©è§†é¢‘åˆ°Blobï¼ˆç›´æ¥è¿”å›Blobç”¨äºä¸Šä¼ ï¼‰
            async compressVideoToBlob(file) {
                console.log(`ğŸ¬ å‹ç¼©è§†é¢‘åˆ°Blob: ${file.name}, åŸå§‹å¤§å°: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
                
                // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨å‹ç¼©
                if (!STORAGE_CONFIG.AUTO_VIDEO_COMPRESSION) {
                    console.log('ğŸ”§ è‡ªåŠ¨è§†é¢‘å‹ç¼©å·²ç¦ç”¨');
                    return file;
                }
                
                const compressionConfig = STORAGE_CONFIG.VIDEO_COMPRESSION;

                // å¦‚æœæ–‡ä»¶å·²ç»å¾ˆå°ï¼Œç›´æ¥è¿”å›
                if (file.size < compressionConfig.skipCompressionSizeMB * 1024 * 1024) {
                    console.log('ğŸ“ æ–‡ä»¶å·²ç»å¾ˆå°ï¼Œè·³è¿‡å‹ç¼©');
                    return file;
                }

                try {
                    // ä½¿ç”¨MediaRecorder APIè¿›è¡Œè§†é¢‘å‹ç¼©ï¼Œç›´æ¥è¿”å›Blob
                    const compressedBlob = await this.compressVideoWithMediaRecorder(file, compressionConfig);
                    
                    if (compressedBlob && compressedBlob.size < file.size) {
                        console.log(`âœ… è§†é¢‘å‹ç¼©åˆ°BlobæˆåŠŸ: ${file.name}, å‹ç¼©åå¤§å°: ${(compressedBlob.size / 1024 / 1024).toFixed(2)} MB`);
                        return compressedBlob;
                    } else {
                        console.log('ğŸ”„ MediaRecorderå‹ç¼©æ•ˆæœä¸ä½³ï¼Œè¿”å›åŸæ–‡ä»¶...');
                        return file;
                    }
                } catch (error) {
                    console.warn('MediaRecorderå‹ç¼©å¤±è´¥ï¼Œè¿”å›åŸæ–‡ä»¶:', error);
                    return file;
                }
            }

            // ğŸ“„ Blobè½¬DataURL
            async blobToDataUrl(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            // ğŸ“„ DataURLè½¬Blob
            dataUrlToBlob(dataUrl) {
                const arr = dataUrl.split(',');
                const mime = arr[0].match(/:(.*?);/)[1];
                const bstr = atob(arr[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                return new Blob([u8arr], { type: mime });
            }

            // ğŸ–¼ï¸ å‹ç¼©å›¾ç‰‡
            async compressImage(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    img.onload = () => {
                        // è®¡ç®—å‹ç¼©å°ºå¯¸
                        let { width, height } = img;
                        const maxDimension = 1920; // æœ€å¤§å°ºå¯¸
                        
                        if (width > maxDimension || height > maxDimension) {
                            const ratio = Math.min(maxDimension / width, maxDimension / height);
                            width *= ratio;
                            height *= ratio;
                        }

                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        resolve(canvas.toDataURL('image/jpeg', STORAGE_CONFIG.IMAGE_QUALITY));
                    };
                    
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            // ğŸ¯ æ™ºèƒ½å›¾ç‰‡å‹ç¼©åˆ°ç›®æ ‡å¤§å°
            async compressImageToTargetSize(file, targetSizeMB = 1) {
                console.log(`ğŸ–¼ï¸ å¼€å§‹æ™ºèƒ½å‹ç¼©å›¾ç‰‡: ${file.name}, åŸå§‹å¤§å°: ${(file.size / 1024 / 1024).toFixed(2)}MB â†’ ç›®æ ‡: ${targetSizeMB}MB`);
                
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    img.onload = async () => {
                        const config = STORAGE_CONFIG.IMAGE_COMPRESSION;
                        let { width, height } = img;
                        
                        // 1. è®¡ç®—æœ€ä½³å°ºå¯¸
                        const maxDimension = Math.min(config.maxWidth, config.maxHeight);
                        if (width > maxDimension || height > maxDimension) {
                            const ratio = Math.min(maxDimension / width, maxDimension / height);
                            width *= ratio;
                            height *= ratio;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // 2. è¿­ä»£å‹ç¼©åˆ°ç›®æ ‡å¤§å°
                        let quality = config.quality;
                        let dataUrl;
                        let attempts = 0;
                        const maxAttempts = 8;
                        const targetSizeBytes = targetSizeMB * 1024 * 1024;
                        
                        do {
                            dataUrl = canvas.toDataURL(config.format, quality);
                            const currentSize = this.estimateDataUrlSize(dataUrl);
                            
                            console.log(`ğŸ” å‹ç¼©å°è¯• ${attempts + 1}: è´¨é‡=${quality.toFixed(2)}, å¤§å°=${(currentSize / 1024 / 1024).toFixed(2)}MB`);
                            
                            if (currentSize <= targetSizeBytes) {
                                console.log(`âœ… å›¾ç‰‡å‹ç¼©æˆåŠŸ: ${file.name}, æœ€ç»ˆå¤§å°: ${(currentSize / 1024 / 1024).toFixed(2)}MB`);
                                break;
                            }
                            
                            // å¦‚æœè¿˜æ˜¯å¤ªå¤§ï¼Œç»§ç»­é™ä½è´¨é‡
                            quality *= 0.8;
                            attempts++;
                            
                            // å¦‚æœè´¨é‡å¤ªä½ï¼Œå°è¯•è¿›ä¸€æ­¥ç¼©å°å°ºå¯¸
                            if (quality < 0.3 && attempts < maxAttempts) {
                                const scale = 0.85;
                                width *= scale;
                                height *= scale;
                                canvas.width = width;
                                canvas.height = height;
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(img, 0, 0, width, height);
                                quality = 0.7; // é‡ç½®è´¨é‡
                                console.log(`ğŸ“ ç¼©å°å°ºå¯¸: ${width.toFixed(0)}x${height.toFixed(0)}`);
                            }
                            
                        } while (attempts < maxAttempts);
                        
                        // 3. è¿”å›æœ€ç»ˆç»“æœ
                        const finalSize = this.estimateDataUrlSize(dataUrl);
                        console.log(`ğŸ¯ å›¾ç‰‡å‹ç¼©å®Œæˆ: ${file.name}, ${(file.size / 1024 / 1024).toFixed(2)}MB â†’ ${(finalSize / 1024 / 1024).toFixed(2)}MB (å‹ç¼©ç‡: ${((1 - finalSize / file.size) * 100).toFixed(1)}%)`);
                        
                        resolve(dataUrl);
                    };
                    
                    img.onerror = (error) => {
                        console.error('å›¾ç‰‡åŠ è½½å¤±è´¥:', error);
                        reject(error);
                    };
                    
                    img.src = URL.createObjectURL(file);
                });
            }

            // ğŸ“ ä¼°ç®—DataURLå¤§å°
            estimateDataUrlSize(dataUrl) {
                // DataURLæ ¼å¼: data:image/jpeg;base64,<base64æ•°æ®>
                const base64Data = dataUrl.split(',')[1];
                if (!base64Data) return 0;
                
                // Base64ç¼–ç å¤§å°çº¦ä¸ºåŸå§‹æ•°æ®çš„4/3
                return (base64Data.length * 3) / 4;
            }

            // ğŸ“„ æ–‡ä»¶è½¬DataURL
            async fileToDataUrl(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            // ğŸ“Š æ›´æ–°å­˜å‚¨ç»Ÿè®¡
            updateStats(posts) {
                let totalSize = 0;
                let fileCount = 0;

                Object.values(posts).forEach(dayPosts => {
                    dayPosts.forEach(post => {
                        if (post.files) {
                            post.files.forEach(file => {
                                fileCount++;
                                if (file.size) totalSize += file.size;
                            });
                        }
                    });
                });

                this.storageStats = {
                    ...this.storageStats,
                    localSize: this.calculateLocalStorageSize(),
                    totalFiles: fileCount
                };

                return this.storageStats;
            }

            // ğŸ§¹ æ™ºèƒ½å­˜å‚¨æ¸…ç†
            cleanupStorage(posts, options = {}) {
                console.log('ğŸ§¹ å¼€å§‹æ™ºèƒ½å­˜å‚¨æ¸…ç†...');
                
                const {
                    maxAgeDays = 30,     // æœ€å¤§ä¿ç•™å¤©æ•°
                    maxSizeMB = 8,       // æœ€å¤§æœ¬åœ°å­˜å‚¨å¤§å°(MB)
                    aggressive = false   // æ¿€è¿›æ¸…ç†æ¨¡å¼
                } = options;
                
                let cleaned = false;
                let cleanupReport = {
                    deletedDates: [],
                    compressedFiles: 0,
                    deletedFiles: 0,
                    freedSpace: 0
                };
                
                // 1. æ¸…ç†è¿‡æœŸæ•°æ®
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);
                
                Object.keys(posts).forEach(dateKey => {
                    const postDate = new Date(dateKey);
                    if (postDate < cutoffDate) {
                        console.log(`ğŸ—‘ï¸ æ¸…ç†è¿‡æœŸæ•°æ®: ${dateKey}`);
                        cleanupReport.deletedDates.push(dateKey);
                        delete posts[dateKey];
                        cleaned = true;
                    }
                });
                
                // 2. è®¡ç®—å½“å‰å­˜å‚¨å¤§å°
                let currentSizeMB = this.calculateLocalStorageSize() / (1024 * 1024);
                
                if (currentSizeMB > maxSizeMB || aggressive) {
                    console.log(`ğŸ“Š å½“å‰å­˜å‚¨: ${currentSizeMB.toFixed(2)}MB, å¼€å§‹æ¸…ç†...`);
                    
                    // 3. ä¼˜å…ˆæ¸…ç†å¤§æ–‡ä»¶çš„DataURLï¼ˆä¿ç•™ç¼©ç•¥å›¾ï¼‰
                    Object.values(posts).forEach(dayPosts => {
                        dayPosts.forEach(post => {
                            if (post.files) {
                                post.files.forEach(file => {
                                    const sizeBefore = file.dataUrl ? file.dataUrl.length : 0;
                                    
                                    // æ¸…ç†å¤§è§†é¢‘çš„DataURLï¼Œåªä¿ç•™ç¼©ç•¥å›¾
                                    if (file.type === 'video' && file.dataUrl && file.dataUrl.length > 2 * 1024 * 1024) {
                                        if (file.thumbnail) {
                                            console.log(`ğŸ¥ æ¸…ç†è§†é¢‘DataURLï¼Œä¿ç•™ç¼©ç•¥å›¾: ${file.name}`);
                                            file.dataUrl = file.thumbnail;
                                            file.needsReprocessing = true;
                                            cleanupReport.compressedFiles++;
                                            cleanupReport.freedSpace += sizeBefore - file.dataUrl.length;
                                            cleaned = true;
                                        } else if (aggressive) {
                                            console.log(`ğŸ—‘ï¸ æ¿€è¿›æ¨¡å¼ï¼šåˆ é™¤æ— ç¼©ç•¥å›¾çš„å¤§è§†é¢‘: ${file.name}`);
                                            file.dataUrl = null;
                                            file.originalDataUrl = null;
                                            cleanupReport.deletedFiles++;
                                            cleanupReport.freedSpace += sizeBefore;
                                            cleaned = true;
                                        }
                                    }
                                    
                                    // æ¸…ç†å¤§å›¾ç‰‡ï¼Œå‹ç¼©è´¨é‡
                                    else if (file.type === 'image' && file.dataUrl && file.dataUrl.length > 1 * 1024 * 1024) {
                                        if (aggressive || !file.isCompressed) {
                                            console.log(`ğŸ–¼ï¸ æ ‡è®°å¤§å›¾ç‰‡éœ€è¦é‡æ–°å‹ç¼©: ${file.name}`);
                                            file.needsReprocessing = true;
                                            cleanupReport.compressedFiles++;
                                            cleaned = true;
                                        }
                                    }
                                });
                            }
                        });
                    });
                    
                    // 4. å¦‚æœè¿˜æ˜¯å¤ªå¤§ï¼Œæ¿€è¿›æ¸…ç†ï¼šåˆ é™¤æœ€è€çš„æ•°æ®
                    if (aggressive && currentSizeMB > maxSizeMB * 1.5) {
                        const sortedDates = Object.keys(posts).sort();
                        const deleteCount = Math.ceil(sortedDates.length * 0.3); // åˆ é™¤30%çš„æœ€è€æ•°æ®
                        
                        for (let i = 0; i < deleteCount && i < sortedDates.length; i++) {
                            const dateKey = sortedDates[i];
                            console.log(`ğŸ”¥ æ¿€è¿›æ¸…ç†ï¼šåˆ é™¤è€æ•°æ® ${dateKey}`);
                            cleanupReport.deletedDates.push(dateKey);
                            delete posts[dateKey];
                            cleaned = true;
                        }
                    }
                }
                
                if (cleaned) {
                    console.log('âœ… æ™ºèƒ½å­˜å‚¨æ¸…ç†å®Œæˆ', cleanupReport);
                    return { posts, cleanupReport, cleaned: true };
                }
                
                return { posts, cleanupReport, cleaned: false };
            }

            // ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰æœ¬åœ°æ•°æ®
            clearAllData() {
                console.log('ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰æœ¬åœ°æ•°æ®...');
                try {
                    localStorage.removeItem('socialMediaCalendar');
                    this.storageStats = {
                        localSize: 0,
                        cloudSize: 0,
                        totalFiles: 0,
                        syncStatus: 'idle'
                    };
                    return true;
                } catch (error) {
                    console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error);
                    return false;
                }
            }
        }

        // å…¨å±€å­˜å‚¨ç®¡ç†å™¨å®ä¾‹
        const storageManager = new SmartStorageManager();
        
        // ğŸš¨ å­˜å‚¨é¢„è­¦ç³»ç»Ÿ
        class StorageWarningSystem {
            constructor() {
                this.lastWarningTime = 0;
                this.warningCooldown = 5 * 60 * 1000; // 5åˆ†é’Ÿå†·å´æœŸ
                this.criticalThreshold = 8 * 1024 * 1024; // 8MBä¸¥é‡é˜ˆå€¼
                this.warningThreshold = 6 * 1024 * 1024;  // 6MBè­¦å‘Šé˜ˆå€¼
            }
            
            checkStorageStatus(storageSize, showMessageFunc) {
                const now = Date.now();
                if (now - this.lastWarningTime < this.warningCooldown) {
                    return; // å†·å´æœŸå†…ä¸é‡å¤è­¦å‘Š
                }
                
                if (storageSize > this.criticalThreshold) {
                    this.lastWarningTime = now;
                    showMessageFunc(
                        'ğŸš¨ å­˜å‚¨ç©ºé—´ä¸¥é‡ä¸è¶³ï¼å»ºè®®ç«‹å³æ¸…ç†æ•°æ®ï¼Œå¦åˆ™å¯èƒ½æ— æ³•ä¿å­˜æ–°å†…å®¹', 
                        'error'
                    );
                    return 'critical';
                } else if (storageSize > this.warningThreshold) {
                    this.lastWarningTime = now;
                    showMessageFunc(
                        'âš ï¸ å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œå»ºè®®æ¸…ç†æ•°æ®ä»¥ç¡®ä¿æ­£å¸¸ä½¿ç”¨', 
                        'warning'
                    );
                    return 'warning';
                }
                
                return 'normal';
            }
            
            // æ™ºèƒ½æ¨èæ¸…ç†æ–¹æ¡ˆ
            recommendCleanupStrategy(storageSize) {
                if (storageSize > this.criticalThreshold) {
                    return {
                        strategy: 'aggressive',
                        message: 'å»ºè®®ä½¿ç”¨æ·±åº¦æ¸…ç†ï¼Œåˆ é™¤7å¤©å‰çš„æ•°æ®',
                        maxAgeDays: 7,
                        maxSizeMB: 2
                    };
                } else if (storageSize > this.warningThreshold) {
                    return {
                        strategy: 'normal',
                        message: 'å»ºè®®ä½¿ç”¨æ™ºèƒ½æ¸…ç†ï¼Œå‹ç¼©å¤§æ–‡ä»¶',
                        maxAgeDays: 30,
                        maxSizeMB: 4
                    };
                }
                
                return null;
            }
        }
        
        const storageWarning = new StorageWarningSystem();

        // å›¾æ ‡ç»„ä»¶
        const ChevronLeft = () => <span>â€¹</span>;
        const ChevronRight = () => <span>â€º</span>;
        const XCircle = () => <span>Ã—</span>;

        // Supabaseæ•°æ®æœåŠ¡
        const SupabaseService = {
            // ä¸Šä¼ æ–‡ä»¶åˆ°Supabase Storage (æ”¯æŒè¿›åº¦å›è°ƒå’Œå‹ç¼©Blob)
            async uploadFile(file, fileName, userId, progressCallback = null, isCompressed = false) {
                try {
                    // éªŒè¯æ–‡ä»¶
                    if (!file || !fileName || !userId) {
                        console.error('ä¸Šä¼ å‚æ•°ä¸å®Œæ•´:', { file: !!file, fileName, userId });
                        return null;
                    }

                    // å¤„ç†å‹ç¼©æ–‡ä»¶çš„æ‰©å±•å
                    let fileExt = fileName.split('.').pop();
                    if (isCompressed && file.type && file.type.includes('webm')) {
                        fileExt = 'webm'; // å‹ç¼©åçš„è§†é¢‘ä½¿ç”¨webmæ‰©å±•å
                    }
                    
                    const filePath = `${userId}/${Date.now()}_${Math.random().toString(36).substring(7)}.${fileExt}`;
                    
                    const sizeInfo = isCompressed ? '(å‹ç¼©å)' : '';
                    if (DEBUG_MODE) console.log(`å¼€å§‹ä¸Šä¼ æ–‡ä»¶: ${fileName} ${sizeInfo}, å¤§å°: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
                    
                    // å¯¹äºå¤§æ–‡ä»¶ï¼Œæ˜¾ç¤ºä¸Šä¼ è¿›åº¦
                    if (progressCallback) {
                        progressCallback(0, fileName);
                    }

                    // åˆ›å»ºä¸€ä¸ªåŒ…è£…çš„æ–‡ä»¶å¯¹è±¡æ¥æ¨¡æ‹Ÿè¿›åº¦
                    let uploadPromise;
                    
                    if (file.size > 1024 * 1024) { // å¤§äº1MBçš„æ–‡ä»¶æ˜¾ç¤ºè¿›åº¦
                        // åˆ›å»ºæ¨¡æ‹Ÿè¿›åº¦çš„Promise
                        uploadPromise = new Promise(async (resolve, reject) => {
                            try {
                                // æ¨¡æ‹Ÿä¸Šä¼ è¿›åº¦
                                let currentProgress = 0;
                                const progressInterval = setInterval(() => {
                                    if (progressCallback && currentProgress < 85) {
                                        currentProgress += Math.random() * 15 + 5;
                                        currentProgress = Math.min(85, currentProgress);
                                        progressCallback(currentProgress, fileName);
                                    }
                                }, 300);

                                const { data, error } = await supabase.storage
                                    .from('media-files')
                                    .upload(filePath, file, {
                                        cacheControl: '3600',
                                        upsert: false
                                    });

                                clearInterval(progressInterval);
                                
                                if (progressCallback) {
                                    progressCallback(100, fileName);
                                }

                                if (error) {
                                    reject(error);
                                } else {
                                    resolve({ data, error });
                                }
                            } catch (err) {
                                reject(err);
                            }
                        });
                    } else {
                        // å°æ–‡ä»¶ç›´æ¥ä¸Šä¼ 
                        uploadPromise = supabase.storage
                            .from('media-files')
                            .upload(filePath, file, {
                                cacheControl: '3600',
                                upsert: false
                            });
                    }

                    const { data, error } = await uploadPromise;

                    if (error) {
                        console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
                        if (progressCallback) {
                            progressCallback(-1, fileName, error.message);
                        }
                        return null;
                    }

                    // è·å–å…¬å…±URL
                    const { data: { publicUrl } } = supabase.storage
                        .from('media-files')
                        .getPublicUrl(filePath);

                    if (DEBUG_MODE) console.log(`æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: ${fileName} -> ${publicUrl}`);

                    return {
                        filePath: filePath,
                        publicUrl: publicUrl,
                        fileName: fileName,
                        fileSize: file.size,
                        fileType: file.type
                    };
                } catch (error) {
                    console.error('ä¸Šä¼ æ–‡ä»¶é”™è¯¯:', error);
                    if (progressCallback) {
                        progressCallback(-1, fileName, error.message);
                    }
                    return null;
                }
            },

            // åˆ é™¤æ–‡ä»¶ä»Supabase Storage
            async deleteFile(filePath) {
                try {
                    const { error } = await supabase.storage
                        .from('media-files')
                        .remove([filePath]);
                    
                    if (error) {
                        console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', error);
                        return false;
                    }
                    return true;
                } catch (error) {
                    console.error('åˆ é™¤æ–‡ä»¶é”™è¯¯:', error);
                    return false;
                }
            },

            // æ‰¹é‡ä¸Šä¼ æ–‡ä»¶
            async uploadFiles(files, userId) {
                const uploadPromises = files.map(async (fileData) => {
                    if (fileData.file) {
                        // å¦‚æœæœ‰åŸå§‹æ–‡ä»¶ï¼Œä¸Šä¼ åˆ°äº‘ç«¯
                        const uploadResult = await this.uploadFile(fileData.file, fileData.name, userId);
                        if (uploadResult) {
                            return {
                                ...fileData,
                                cloudUrl: uploadResult.publicUrl,
                                cloudPath: uploadResult.filePath,
                                uploaded: true
                            };
                        }
                    }
                    return {
                        ...fileData,
                        uploaded: false
                    };
                });

                return await Promise.all(uploadPromises);
            },

            // ä¿å­˜å‘å¸ƒå†…å®¹åˆ°äº‘ç«¯ï¼ˆåŒ…å«æ–‡ä»¶ä¸Šä¼ ï¼‰
            async savePosts(posts, progressCallback = null) {
                if (!isSupabaseConfigured) return;
                
                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    if (!user) return;

                    if (DEBUG_MODE) console.log('å¼€å§‹ä¿å­˜æ•°æ®åˆ°äº‘ç«¯...');

                    // å¤„ç†æ¯ä¸ªæ—¥æœŸçš„å¸–å­
                    for (const [date, dayPosts] of Object.entries(posts)) {
                        for (const post of dayPosts) {
                            try {
                                // æš‚æ—¶è·³è¿‡æ–‡ä»¶ä¸Šä¼ ï¼Œä»…ä¿å­˜æ–‡æ¡ˆå’Œå¹³å°ä¿¡æ¯
                                let uploadedFiles = post.files || [];
                                
                                // é‡æ–°å¯ç”¨æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½ï¼Œä½¿ç”¨æ›´å®‰å…¨çš„æ–¹å¼
                                if (post.files && post.files.length > 0) {
                                    if (DEBUG_MODE) console.log(`æ­£åœ¨ä¸Šä¼  ${post.files.length} ä¸ªæ–‡ä»¶...`);
                                    
                                    uploadedFiles = []; // é‡æ–°åˆå§‹åŒ–
                                    
                                    for (const fileData of post.files) {
                                        try {
                                            if ((fileData.file || fileData.compressedBlob) && !fileData.cloudUrl && !fileData.uploaded) {
                                                // ğŸ¥ ä¼˜å…ˆä¸Šä¼ å‹ç¼©åçš„Blobï¼ˆç”¨äºè§†é¢‘ï¼‰
                                                if (fileData.uploadCompressed && fileData.compressedBlob) {
                                                    if (DEBUG_MODE) console.log(`ä¸Šä¼ å‹ç¼©è§†é¢‘: ${fileData.name}`);
                                                    const uploadResult = await this.uploadFile(
                                                        fileData.compressedBlob, 
                                                        fileData.name, 
                                                        user.id, 
                                                        progressCallback, 
                                                        true // æ ‡è®°ä¸ºå‹ç¼©æ–‡ä»¶
                                                    );
                                                    
                                                    if (uploadResult) {
                                                        uploadedFiles.push({
                                                            ...fileData,
                                                            cloudUrl: uploadResult.publicUrl,
                                                            cloudPath: uploadResult.filePath,
                                                            uploaded: true,
                                                            isCloudCompressed: true, // æ ‡è®°ä¸ºäº‘ç«¯å‹ç¼©æ–‡ä»¶
                                                            // æœ¬åœ°åªä¿ç•™ç¼©ç•¥å›¾ï¼Œäº‘ç«¯URLç”¨äºæ’­æ”¾
                                                            dataUrl: fileData.thumbnail,
                                                            originalDataUrl: uploadResult.publicUrl,
                                                            file: null,           // æ¸…é™¤åŸå§‹æ–‡ä»¶
                                                            compressedBlob: null  // æ¸…é™¤å‹ç¼©Blobï¼ŒèŠ‚çœå†…å­˜
                                                        });
                                                        if (DEBUG_MODE) console.log(`å‹ç¼©è§†é¢‘ä¸Šä¼ æˆåŠŸ: ${fileData.name} -> ${fileData.compressedSize}`);
                                                    } else {
                                                        // å‹ç¼©ä¸Šä¼ å¤±è´¥ï¼Œå°è¯•åŸæ–‡ä»¶
                                                        if (DEBUG_MODE) console.log(`å‹ç¼©ä¸Šä¼ å¤±è´¥ï¼Œå°è¯•åŸæ–‡ä»¶: ${fileData.name}`);
                                                        const originalUpload = await this.uploadFile(fileData.file, fileData.name, user.id, progressCallback);
                                                        if (originalUpload) {
                                                            uploadedFiles.push({
                                                                ...fileData,
                                                                cloudUrl: originalUpload.publicUrl,
                                                                cloudPath: originalUpload.filePath,
                                                                uploaded: true,
                                                                dataUrl: fileData.thumbnail,
                                                                originalDataUrl: originalUpload.publicUrl,
                                                                file: null,
                                                                compressedBlob: null
                                                            });
                                                        } else {
                                                            uploadedFiles.push({ ...fileData, uploaded: false });
                                                        }
                                                    }
                                                } else {
                                                    // å¸¸è§„æ–‡ä»¶ä¸Šä¼ 
                                                    if (DEBUG_MODE) console.log(`ä¸Šä¼ åŸæ–‡ä»¶: ${fileData.name}`);
                                                    const uploadResult = await this.uploadFile(fileData.file, fileData.name, user.id, progressCallback);
                                                    
                                                    if (uploadResult) {
                                                        uploadedFiles.push({
                                                            ...fileData,
                                                            cloudUrl: uploadResult.publicUrl,
                                                            cloudPath: uploadResult.filePath,
                                                            uploaded: true,
                                                            // å¯¹äºè§†é¢‘ï¼Œä¿ç•™ç¼©ç•¥å›¾ä½œä¸ºé¢„è§ˆï¼Œäº‘ç«¯URLä½œä¸ºæ’­æ”¾æº
                                                            dataUrl: fileData.type === 'video' ? fileData.thumbnail : fileData.dataUrl,
                                                            originalDataUrl: uploadResult.publicUrl, // ä½¿ç”¨äº‘ç«¯URLä½œä¸ºåŸå§‹URL
                                                            file: null // æ¸…é™¤åŸå§‹æ–‡ä»¶å¯¹è±¡ï¼ŒèŠ‚çœå†…å­˜
                                                        });
                                                        if (DEBUG_MODE) console.log(`æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: ${fileData.name}`);
                                                    } else {
                                                        // ä¸Šä¼ å¤±è´¥ï¼Œä¿ç•™åŸå§‹æ•°æ®ä½†æ ‡è®°ä¸ºæœ¬åœ°æ–‡ä»¶
                                                        uploadedFiles.push({
                                                            ...fileData,
                                                            uploaded: false
                                                        });
                                                        if (DEBUG_MODE) console.log(`æ–‡ä»¶ä¸Šä¼ å¤±è´¥ï¼Œä¿ç•™æœ¬åœ°: ${fileData.name}`);
                                                    }
                                                }
                                            } else {
                                                // å·²ç»ä¸Šä¼ è¿‡çš„æ–‡ä»¶æˆ–å·²æœ‰äº‘ç«¯URL
                                                uploadedFiles.push({
                                                    ...fileData,
                                                    uploaded: fileData.cloudUrl ? true : false
                                                });
                                            }
                                        } catch (fileError) {
                                            if (DEBUG_MODE) console.error(`å¤„ç†æ–‡ä»¶å¤±è´¥: ${fileData.name}`, fileError);
                                            // å³ä½¿å‡ºé”™ä¹Ÿä¿ç•™æ–‡ä»¶
                                            uploadedFiles.push({
                                                ...fileData,
                                                uploaded: false
                                            });
                                        }
                                    }
                                }

                                // ä¿å­˜å¸–å­æ•°æ®åˆ°æ•°æ®åº“
                                const postData = {
                                    user_id: user.id,
                                    date,
                                    caption: post.caption || '',
                                    platforms: post.platforms || []
                                };

                                // åˆ é™¤è¯¥æ—¥æœŸçš„ç°æœ‰æ•°æ®
                                await supabase.from('posts').delete().eq('user_id', user.id).eq('date', date);
                                
                                // æ’å…¥æ–°æ•°æ®
                                const { data: insertedPost, error: postError } = await supabase
                                    .from('posts')
                                    .insert(postData)
                                    .select()
                                    .single();

                                if (postError) {
                                    console.log('æ•°æ®åº“è¡¨å°šæœªåˆ›å»ºï¼Œè·³è¿‡æ•°æ®åº“ä¿å­˜');
                                    continue;
                                }

                                // ä¿å­˜æ–‡ä»¶ä¿¡æ¯åˆ°æ•°æ®åº“
                                if (uploadedFiles.length > 0 && insertedPost) {
                                    const mediaData = uploadedFiles.map(file => ({
                                        post_id: insertedPost.id,
                                        file_name: file.name,
                                        file_type: file.type.startsWith('image') ? 'image' : 'video',
                                        file_url: file.cloudUrl || file.dataUrl,
                                        thumbnail_url: file.thumbnail,
                                        compressed_url: file.dataUrl,
                                        file_size: file.size,
                                        original_name: file.name
                                    }));

                                    const { error: mediaError } = await supabase
                                        .from('media_files')
                                        .insert(mediaData);

                                    if (mediaError) {
                                        console.log('åª’ä½“æ–‡ä»¶è¡¨å°šæœªåˆ›å»ºï¼Œä»…ä¿å­˜å¸–å­æ•°æ®');
                                    }
                                }

                                // æ›´æ–°æœ¬åœ°æ•°æ®ä¸­çš„äº‘ç«¯ä¿¡æ¯
                                if (uploadedFiles.length > 0) {
                                    post.files = uploadedFiles;
                                }

                            } catch (postError) {
                                console.error('ä¿å­˜å•ä¸ªå¸–å­å¤±è´¥:', postError);
                            }
                        }
                    }

                                                        if (DEBUG_MODE) console.log('äº‘ç«¯ä¿å­˜å®Œæˆ');
                                    
                                    // ç»Ÿè®¡ä¸Šä¼ ç»“æœ
                                    const totalFiles = Object.values(posts).reduce((total, dayPosts) => {
                                        return total + dayPosts.reduce((dayTotal, post) => {
                                            return dayTotal + (post.files ? post.files.length : 0);
                                        }, 0);
                                    }, 0);
                                    
                                    if (totalFiles > 0) {
                                        if (DEBUG_MODE) console.log(`å¤„ç†äº† ${totalFiles} ä¸ªæ–‡ä»¶`);
                                    }
                } catch (error) {
                    console.error('Supabaseä¿å­˜é”™è¯¯:', error);
                }
            },

            // åªä¿å­˜æ–‡æ¡ˆåˆ°äº‘ç«¯ï¼ˆä¸ä¸Šä¼ æ–‡ä»¶ï¼‰
            async savePostsTextOnly(posts) {
                if (!isSupabaseConfigured) return;
                
                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    if (!user) return;

                    if (DEBUG_MODE) console.log('å¼€å§‹åŒæ­¥æ–‡æ¡ˆåˆ°äº‘ç«¯...');

                    // åªå¤„ç†æ–‡æ¡ˆå’Œå¹³å°ä¿¡æ¯ï¼Œè·³è¿‡æ–‡ä»¶
                    for (const [date, dayPosts] of Object.entries(posts)) {
                        for (const post of dayPosts) {
                            try {
                                // ä¿å­˜å¸–å­æ•°æ®åˆ°æ•°æ®åº“ï¼ˆä¸åŒ…å«æ–‡ä»¶ï¼‰
                                const postData = {
                                    user_id: user.id,
                                    date,
                                    caption: post.caption || '',
                                    platforms: post.platforms || []
                                };

                                // åˆ é™¤è¯¥æ—¥æœŸçš„ç°æœ‰æ•°æ®
                                await supabase.from('posts').delete().eq('user_id', user.id).eq('date', date);
                                
                                // æ’å…¥æ–°æ•°æ®
                                const { error: postError } = await supabase
                                    .from('posts')
                                    .insert(postData);

                                if (postError) {
                                    if (DEBUG_MODE) console.log('æ•°æ®åº“è¡¨å°šæœªåˆ›å»ºï¼Œè·³è¿‡æ•°æ®åº“ä¿å­˜');
                                    continue;
                                }

                            } catch (postError) {
                                console.error('ä¿å­˜å•ä¸ªå¸–å­å¤±è´¥:', postError);
                            }
                        }
                    }

                    if (DEBUG_MODE) console.log('æ–‡æ¡ˆåŒæ­¥å®Œæˆ');
                } catch (error) {
                    console.error('Supabaseæ–‡æ¡ˆåŒæ­¥é”™è¯¯:', error);
                }
            },

            // ä»äº‘ç«¯åŠ è½½å‘å¸ƒå†…å®¹ï¼ˆåŒ…å«æ–‡ä»¶ï¼‰
            async loadPosts() {
                if (!isSupabaseConfigured) return null;
                
                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    if (!user) return null;

                    console.log('ä»äº‘ç«¯åŠ è½½æ•°æ®...');

                    // å°è¯•ä»æ•°æ®åº“åŠ è½½ï¼Œå¦‚æœå¤±è´¥å°±è¿”å›nullï¼ˆä¿æŒæœ¬åœ°æ•°æ®ï¼‰
                    try {
                        // åŠ è½½å¸–å­æ•°æ®ï¼ŒåŒ…å«å…³è”çš„åª’ä½“æ–‡ä»¶
                        const { data: postsData, error: postsError } = await supabase
                            .from('posts')
                            .select(`
                                *,
                                media_files (*)
                            `)
                            .eq('user_id', user.id)
                            .order('date', { ascending: true });

                        if (postsError) {
                            console.log('äº‘ç«¯æš‚æ— æ•°æ®ï¼Œä¿æŒæœ¬åœ°æ•°æ®');
                            return null;
                        }

                        if (!postsData || postsData.length === 0) {
                            console.log('äº‘ç«¯æ•°æ®ä¸ºç©º');
                            return {};
                        }

                        // è½¬æ¢ä¸ºåŸæœ‰æ ¼å¼
                        const posts = {};
                        postsData.forEach(post => {
                            if (!posts[post.date]) posts[post.date] = [];
                            
                            // å¤„ç†åª’ä½“æ–‡ä»¶
                            const files = (post.media_files || []).map(mediaFile => {
                                const isVideo = mediaFile.file_type === 'video';
                                return {
                                    name: mediaFile.original_name || mediaFile.file_name,
                                    type: isVideo ? 'video' : 'image',
                                    size: mediaFile.file_size || 0,
                                    // å¯¹äºè§†é¢‘ï¼šdataUrlç”¨ç¼©ç•¥å›¾é¢„è§ˆï¼ŒoriginalDataUrlå’ŒcloudUrlç”¨äº‘ç«¯URL
                                    dataUrl: isVideo ? (mediaFile.thumbnail_url || mediaFile.compressed_url) : (mediaFile.compressed_url || mediaFile.file_url),
                                    originalDataUrl: mediaFile.file_url, // äº‘ç«¯URLï¼Œç”¨äºæ’­æ”¾
                                    cloudUrl: mediaFile.file_url, // äº‘ç«¯URL
                                    cloudPath: mediaFile.file_name,
                                    thumbnail: mediaFile.thumbnail_url,
                                    uploaded: true
                                };
                            });

                            posts[post.date].push({
                                caption: post.caption,
                                platforms: post.platforms,
                                files: files
                            });
                        });

                        console.log(`æˆåŠŸåŠ è½½ ${Object.keys(posts).length} ä¸ªæ—¥æœŸçš„æ•°æ®`);
                        return posts;
                    } catch (dbError) {
                        console.log('æ•°æ®åº“è¡¨å°šæœªåˆ›å»ºæˆ–è¿æ¥å¤±è´¥ï¼Œä¿æŒæœ¬åœ°æ•°æ®');
                        return null;
                    }
                } catch (error) {
                    console.error('SupabaseåŠ è½½é”™è¯¯:', error);
                    return null;
                }
            },

            // åªä»äº‘ç«¯åŠ è½½æ–‡æ¡ˆï¼ˆä¸åŠ è½½æ–‡ä»¶ï¼‰
            async loadTextOnlyPosts() {
                if (!isSupabaseConfigured) return null;
                
                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    if (!user) return null;

                    if (DEBUG_MODE) console.log('ä»äº‘ç«¯åŠ è½½æ–‡æ¡ˆæ•°æ®...');

                    try {
                        // åªåŠ è½½å¸–å­æ•°æ®ï¼Œä¸åŒ…å«åª’ä½“æ–‡ä»¶
                        const { data: postsData, error: postsError } = await supabase
                            .from('posts')
                            .select('*')
                            .eq('user_id', user.id)
                            .order('date', { ascending: true });

                        if (postsError) {
                            if (DEBUG_MODE) console.log('äº‘ç«¯æš‚æ— æ•°æ®ï¼Œä¿æŒæœ¬åœ°æ•°æ®');
                            return null;
                        }

                        if (!postsData || postsData.length === 0) {
                            if (DEBUG_MODE) console.log('äº‘ç«¯æ–‡æ¡ˆæ•°æ®ä¸ºç©º');
                            return {};
                        }

                        // è½¬æ¢ä¸ºåŸæœ‰æ ¼å¼ï¼ˆåªåŒ…å«æ–‡æ¡ˆï¼Œä¸åŒ…å«æ–‡ä»¶ï¼‰
                        const posts = {};
                        postsData.forEach(post => {
                            if (!posts[post.date]) posts[post.date] = [];
                            
                            posts[post.date].push({
                                caption: post.caption,
                                platforms: post.platforms,
                                files: [] // ä¸åŠ è½½æ–‡ä»¶ï¼Œä¿æŒç©ºæ•°ç»„
                            });
                        });

                        if (DEBUG_MODE) console.log(`æˆåŠŸåŠ è½½ ${Object.keys(posts).length} ä¸ªæ—¥æœŸçš„æ–‡æ¡ˆæ•°æ®`);
                        return posts;
                    } catch (dbError) {
                        if (DEBUG_MODE) console.log('æ•°æ®åº“è¡¨å°šæœªåˆ›å»ºæˆ–è¿æ¥å¤±è´¥ï¼Œä¿æŒæœ¬åœ°æ•°æ®');
                        return null;
                    }
                } catch (error) {
                    console.error('Supabaseæ–‡æ¡ˆåŠ è½½é”™è¯¯:', error);
                    return null;
                }
            },

            // ç”¨æˆ·è®¤è¯
            async signIn(email, password) {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email, password
                });
                return { data, error };
            },

            async signUp(email, password) {
                const { data, error } = await supabase.auth.signUp({
                    email, password
                });
                return { data, error };
            },

            async signOut() {
                const { error } = await supabase.auth.signOut();
                return { error };
            },

            async getCurrentUser() {
                const { data: { user } } = await supabase.auth.getUser();
                return user;
            },

            // ğŸ”— æ£€æŸ¥äº‘ç«¯è¿æ¥çŠ¶æ€
            async checkConnection() {
                if (!isSupabaseConfigured) {
                    return {
                        status: 'not_configured',
                        message: 'Supabaseæœªé…ç½®',
                        details: 'URLæˆ–API Keyæœªè®¾ç½®'
                    };
                }

                try {
                    console.log('ğŸ” å¼€å§‹æ£€æŸ¥äº‘ç«¯è¿æ¥...');
                    
                    // 1. æµ‹è¯•åŸºç¡€è¿æ¥
                    const startTime = Date.now();
                    const { data, error } = await supabase.auth.getSession();
                    const responseTime = Date.now() - startTime;
                    
                    if (error) {
                        return {
                            status: 'connection_error',
                            message: 'è¿æ¥å¤±è´¥',
                            details: error.message,
                            responseTime
                        };
                    }

                    // 2. æµ‹è¯•æ•°æ®åº“è¿æ¥
                    try {
                        const { data: testData, error: dbError } = await supabase
                            .from('posts')
                            .select('count')
                            .limit(1);
                        
                        if (dbError && !dbError.message.includes('relation "posts" does not exist')) {
                            return {
                                status: 'database_error',
                                message: 'æ•°æ®åº“è¿æ¥å¤±è´¥',
                                details: dbError.message,
                                responseTime
                            };
                        }
                    } catch (dbError) {
                        console.warn('æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´¥:', dbError);
                    }

                    // 3. æµ‹è¯•å­˜å‚¨è¿æ¥
                    try {
                        const { data: buckets, error: storageError } = await supabase.storage.listBuckets();
                        if (storageError) {
                            console.warn('å­˜å‚¨è¿æ¥æµ‹è¯•å¤±è´¥:', storageError);
                        }
                    } catch (storageError) {
                        console.warn('å­˜å‚¨è¿æ¥æµ‹è¯•å¤±è´¥:', storageError);
                    }

                    // 4. æ£€æŸ¥ç”¨æˆ·è®¤è¯çŠ¶æ€
                    const user = data?.session?.user;
                    const authStatus = user ? 'authenticated' : 'anonymous';

                    return {
                        status: 'connected',
                        message: 'è¿æ¥æ­£å¸¸',
                        details: {
                            authStatus,
                            userId: user?.id || null,
                            email: user?.email || null,
                            responseTime: `${responseTime}ms`,
                            supabaseUrl: SUPABASE_URL,
                            timestamp: new Date().toISOString()
                        }
                    };

                } catch (error) {
                    console.error('äº‘ç«¯è¿æ¥æ£€æŸ¥å¤±è´¥:', error);
                    return {
                        status: 'error',
                        message: 'æ£€æŸ¥å¤±è´¥',
                        details: error.message
                    };
                }
            }
        };

        // è®¤è¯æ¨¡æ€æ¡†ç»„ä»¶
        const AuthModal = ({ showTemporaryMessage }) => {
            const [showAuthModal, setShowAuthModal] = React.useState(false);
            const [isSignUp, setIsSignUp] = React.useState(false);
            const [email, setEmail] = React.useState('');
            const [password, setPassword] = React.useState('');
            const [loading, setLoading] = React.useState(false);

            const handleAuth = async (e) => {
                e.preventDefault();
                setLoading(true);

                try {
                    if (isSignUp) {
                        const { data, error } = await SupabaseService.signUp(email, password);
                        if (error) {
                            showTemporaryMessage(error.message, 'error');
                        } else {
                            showTemporaryMessage('æ³¨å†ŒæˆåŠŸï¼è¯·æ£€æŸ¥é‚®ç®±éªŒè¯é“¾æ¥ã€‚', 'success');
                            setShowAuthModal(false);
                        }
                    } else {
                        const { data, error } = await SupabaseService.signIn(email, password);
                        if (error) {
                            showTemporaryMessage(error.message, 'error');
                        } else {
                            showTemporaryMessage('ç™»å½•æˆåŠŸï¼', 'success');
                            setShowAuthModal(false);
                        }
                    }
                } catch (error) {
                    showTemporaryMessage('æ“ä½œå¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                } finally {
                    setLoading(false);
                }
            };

            return (
                <>
                    <button
                        onClick={() => setShowAuthModal(true)}
                        className="text-xs px-2 py-1 bg-blue-50 text-blue-600 rounded hover:bg-blue-100 transition-colors"
                    >
                        ç™»å½•/æ³¨å†Œ
                    </button>

                    {showAuthModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div className="bg-white rounded-lg p-6 w-full max-w-md">
                                <h2 className="text-xl font-bold mb-4 text-center">
                                    {isSignUp ? 'æ³¨å†Œè´¦å·' : 'ç™»å½•è´¦å·'}
                                </h2>
                                
                                <form onSubmit={handleAuth} className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">
                                            é‚®ç®±
                                        </label>
                                        <input
                                            type="email"
                                            value={email}
                                            onChange={(e) => setEmail(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                            required
                                        />
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">
                                            å¯†ç 
                                        </label>
                                        <input
                                            type="password"
                                            value={password}
                                            onChange={(e) => setPassword(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                            minLength="6"
                                            required
                                        />
                                    </div>
                                    
                                    <div className="flex gap-3">
                                        <button
                                            type="button"
                                            onClick={() => setShowAuthModal(false)}
                                            className="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition-colors"
                                            disabled={loading}
                                        >
                                            å–æ¶ˆ
                                        </button>
                                        <button
                                            type="submit"
                                            className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors disabled:opacity-50"
                                            disabled={loading}
                                        >
                                            {loading ? 'å¤„ç†ä¸­...' : (isSignUp ? 'æ³¨å†Œ' : 'ç™»å½•')}
                                        </button>
                                    </div>
                                </form>
                                
                                <div className="mt-4 text-center">
                                    <button
                                        type="button"
                                        onClick={() => setIsSignUp(!isSignUp)}
                                        className="text-sm text-blue-600 hover:text-blue-800"
                                        disabled={loading}
                                    >
                                        {isSignUp ? 'å·²æœ‰è´¦å·ï¼Ÿå»ç™»å½•' : 'æ²¡æœ‰è´¦å·ï¼Ÿå»æ³¨å†Œ'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </>
            );
        };

        const App = () => {
            const [currentDate, setCurrentDate] = React.useState(new Date());
            const [user, setUser] = React.useState(null);
            const [isLoading, setIsLoading] = React.useState(true);
            const [scheduledPosts, setScheduledPosts] = React.useState(() => {
                try {
                    const saved = localStorage.getItem('socialMediaCalendar');
                    const data = saved ? JSON.parse(saved) : {};
                    
                    console.log('åŠ è½½æœ¬åœ°æ•°æ®...');
                    
                    // ç®€å•çš„æ•°æ®ä¿®å¤ï¼šåªå¤„ç†æ— æ•ˆçš„blob URL
                    Object.keys(data).forEach(dayKey => {
                        if (data[dayKey] && Array.isArray(data[dayKey])) {
                            data[dayKey].forEach(post => {
                                if (post.files && Array.isArray(post.files)) {
                                    post.files.forEach(file => {
                                        // ä¿®å¤æ— æ•ˆçš„blob URLs
                                        if (file.dataUrl && file.dataUrl.startsWith('blob:')) {
                                            console.warn(`ä¿®å¤æ— æ•ˆçš„blob URL: ${file.name}`);
                                            file.dataUrl = file.thumbnail || file.originalDataUrl;
                                        }
                                        if (file.originalDataUrl && file.originalDataUrl.startsWith('blob:')) {
                                            file.originalDataUrl = file.dataUrl || file.thumbnail;
                                        }
                                    });
                                }
                            });
                        }
                    });
                    
                    console.log('æœ¬åœ°æ•°æ®åŠ è½½å®Œæˆ');
                    return data;
                } catch (error) {
                    console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
                    return {};
                }
            });
            const [showModal, setShowModal] = React.useState(false);
            const [selectedDay, setSelectedDay] = React.useState(null);
            const [selectedFiles, setSelectedFiles] = React.useState([]);
            const [selectedPlatforms, setSelectedPlatforms] = React.useState([]);
            const [captionInput, setCaptionInput] = React.useState('');
            const [message, setMessage] = React.useState({ text: '', type: '' });
            const [currentTime, setCurrentTime] = React.useState(new Date());
            const [lightboxMedia, setLightboxMedia] = React.useState(null);
            const [carouselIndices, setCarouselIndices] = React.useState({});
            const [notificationsEnabled, setNotificationsEnabled] = React.useState(false);
            const [uploadProgress, setUploadProgress] = React.useState({});
            const [isUploading, setIsUploading] = React.useState(false);
            const [uploadStatus, setUploadStatus] = React.useState('');
            const [currentLightboxIndex, setCurrentLightboxIndex] = React.useState(0);

            const platforms = [
                { name: 'IG', url: 'https://www.instagram.com/' },
                { name: 'FB', url: 'https://www.facebook.com/' },
                { name: 'å°çº¢ä¹¦', url: 'https://www.xiaohongshu.com/' },
                { name: 'æŠ–éŸ³', url: 'https://www.douyin.com/' },
                { name: 'å¾®åš', url: 'https://weibo.com/' },
                { name: 'å¾®ä¿¡', url: 'https://mp.weixin.qq.com/' }
            ];

            // ğŸ“¦ æ™ºèƒ½å­˜å‚¨å’ŒåŒæ­¥é€»è¾‘
            React.useEffect(() => {
                // é˜²æ­¢ç©ºæ•°æ®è§¦å‘å­˜å‚¨
                if (!scheduledPosts || Object.keys(scheduledPosts).length === 0) {
                    return;
                }

                try {
                    // 1. ç«‹å³ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                    const dataToStore = JSON.stringify(scheduledPosts);
                    
                    // æ™ºèƒ½å­˜å‚¨ç©ºé—´ç®¡ç†
                    const dataSizeMB = dataToStore.length / (1024 * 1024);
                    console.log(`ğŸ“Š æ•°æ®å¤§å°: ${dataSizeMB.toFixed(2)}MB`);
                    
                    if (dataSizeMB > 5) { // 5MBé™åˆ¶
                        console.warn('âš ï¸ æ•°æ®è¿‡å¤§ï¼Œå¯åŠ¨æ™ºèƒ½æ¸…ç†...');
                        showTemporaryMessage('ğŸ§¹ å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œæ­£åœ¨è‡ªåŠ¨æ¸…ç†...', 'info');
                        
                        // æ™ºèƒ½æ¸…ç†å­˜å‚¨ç©ºé—´
                        const cleanupResult = storageManager.cleanupStorage({...scheduledPosts}, {
                            maxSizeMB: 4,
                            maxAgeDays: 30,
                            aggressive: dataSizeMB > 8 // è¶…è¿‡8MBå¯ç”¨æ¿€è¿›æ¨¡å¼
                        });
                        
                        if (cleanupResult.cleaned) {
                            const cleanedDataToStore = JSON.stringify(cleanupResult.posts);
                            const newSizeMB = cleanedDataToStore.length / (1024 * 1024);
                            
                            console.log(`âœ… æ™ºèƒ½æ¸…ç†å®Œæˆ: ${dataSizeMB.toFixed(2)}MB â†’ ${newSizeMB.toFixed(2)}MB`);
                            localStorage.setItem('socialMediaCalendar', cleanedDataToStore);
                            
                            // æ˜¾ç¤ºæ¸…ç†æŠ¥å‘Š
                            const report = cleanupResult.cleanupReport;
                            const freedMB = ((dataToStore.length - cleanedDataToStore.length) / (1024 * 1024)).toFixed(1);
                            showTemporaryMessage(
                                `ğŸ§¹ æ¸…ç†å®Œæˆ: é‡Šæ”¾ ${freedMB}MBï¼Œä¼˜åŒ– ${report.compressedFiles + report.deletedFiles} ä¸ªæ–‡ä»¶`,
                                'success'
                            );
                            
                            // æ›´æ–°ReactçŠ¶æ€ä»¥åæ˜ æ¸…ç†åçš„æ•°æ®
                            setScheduledPosts(cleanupResult.posts);
                            return;
                        } else {
                            showTemporaryMessage('âš ï¸ è‡ªåŠ¨æ¸…ç†æ— æ³•é‡Šæ”¾è¶³å¤Ÿç©ºé—´ï¼Œå»ºè®®æ‰‹åŠ¨ç®¡ç†æ•°æ®', 'warning');
                        }
                    }
                    
                    localStorage.setItem('socialMediaCalendar', dataToStore);
                    console.log('âœ… æœ¬åœ°å­˜å‚¨å·²æ›´æ–°');
                    
                    // 2. æ›´æ–°å­˜å‚¨ç»Ÿè®¡
                    const stats = storageManager.updateStats(scheduledPosts);
                    
                    // 3. å­˜å‚¨ç©ºé—´é¢„è­¦æ£€æŸ¥
                    const storageStatus = storageWarning.checkStorageStatus(stats.localSize, showTemporaryMessage);
                    
                    // å¦‚æœå­˜å‚¨ç©ºé—´ç´§å¼ ï¼Œæ˜¾ç¤ºæ¸…ç†å»ºè®®
                    if (storageStatus !== 'normal') {
                        const recommendation = storageWarning.recommendCleanupStrategy(stats.localSize);
                        if (recommendation) {
                            console.log('ğŸ’¡ æ¸…ç†å»ºè®®:', recommendation.message);
                        }
                    }
                    
                    // 3. æ™ºèƒ½äº‘ç«¯åŒæ­¥ç­–ç•¥
                    if (user && isSupabaseConfigured && STORAGE_CONFIG.AUTO_CLOUD_SYNC) {
                        // è®¾ç½®åŒæ­¥çŠ¶æ€
                        storageManager.storageStats.syncStatus = 'syncing';
                        
                        const delayedSync = setTimeout(async () => {
                            try {
                                showTemporaryMessage('ğŸ”„ æ™ºèƒ½åŒæ­¥ä¸­...', 'info');
                                
                                // æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦äº‘ç«¯ä¸Šä¼ çš„æ–‡ä»¶
                                let hasCloudFiles = false;
                                Object.values(scheduledPosts).forEach(dayPosts => {
                                    dayPosts.forEach(post => {
                                        if (post.files) {
                                            post.files.forEach(file => {
                                                if (file.needsCloudUpload && !file.cloudUrl) {
                                                    hasCloudFiles = true;
                                                }
                                            });
                                        }
                                    });
                                });
                                
                                if (hasCloudFiles && stats.totalFiles < 10) {
                                    // å°é‡æ–‡ä»¶ï¼šå®Œæ•´åŒæ­¥ï¼ˆåŒ…å«æ–‡ä»¶ä¸Šä¼ ï¼‰
                                    console.log('ğŸ“¤ æ‰§è¡Œå®Œæ•´åŒæ­¥ï¼ˆåŒ…å«æ–‡ä»¶ï¼‰');
                                    await SupabaseService.savePosts(scheduledPosts);
                                    showTemporaryMessage('âœ… å®Œæ•´åŒæ­¥æˆåŠŸï¼', 'success');
                                } else {
                                    // å¤§é‡æ–‡ä»¶æˆ–æ— éœ€ä¸Šä¼ ï¼šä»…åŒæ­¥æ–‡æ¡ˆ
                                    console.log('ğŸ“ æ‰§è¡Œæ–‡æ¡ˆåŒæ­¥');
                                    await SupabaseService.savePostsTextOnly(scheduledPosts);
                                    showTemporaryMessage('âœ… æ–‡æ¡ˆåŒæ­¥å®Œæˆï¼ï¼ˆæ–‡ä»¶ä¿æŒæœ¬åœ°ï¼‰', 'success');
                                }
                                
                                storageManager.storageStats.syncStatus = 'success';
                                
                            } catch (error) {
                                console.error('âŒ äº‘ç«¯åŒæ­¥å¤±è´¥:', error);
                                storageManager.storageStats.syncStatus = 'error';
                                showTemporaryMessage('âš ï¸ äº‘ç«¯åŒæ­¥å¤±è´¥ï¼Œæ•°æ®å·²ä¿å­˜åœ¨æœ¬åœ°', 'warning');
                            }
                        }, STORAGE_CONFIG.SYNC_DELAY);
                        
                        return () => clearTimeout(delayedSync);
                    }
                } catch (error) {
                    console.error('âŒ æœ¬åœ°å­˜å‚¨å¤±è´¥:', error);
                    
                    // æ™ºèƒ½é”™è¯¯å¤„ç†å’Œè‡ªåŠ¨ä¿®å¤
                    if (error.name === 'QuotaExceededError' || error.code === 22) {
                        console.warn('ğŸ’¾ å­˜å‚¨é…é¢è¶…é™ï¼Œå°è¯•æ¿€è¿›æ¸…ç†...');
                        showTemporaryMessage('ğŸ”§ å­˜å‚¨ç©ºé—´ä¸¥é‡ä¸è¶³ï¼Œæ­£åœ¨ç´§æ€¥æ¸…ç†...', 'warning');
                        
                        try {
                            // æ¿€è¿›æ¸…ç†æ¨¡å¼ï¼šæ›´çŸ­çš„ä¿ç•™æœŸå’Œæ›´å°çš„é™åˆ¶
                            const emergencyCleanup = storageManager.cleanupStorage({...scheduledPosts}, {
                                maxSizeMB: 2,
                                maxAgeDays: 7,     // ä»…ä¿ç•™7å¤©æ•°æ®
                                aggressive: true   // å¯ç”¨æ¿€è¿›æ¨¡å¼
                            });
                            
                            if (emergencyCleanup.cleaned) {
                                const emergencyDataToStore = JSON.stringify(emergencyCleanup.posts);
                                localStorage.setItem('socialMediaCalendar', emergencyDataToStore);
                                setScheduledPosts(emergencyCleanup.posts);
                                
                                const report = emergencyCleanup.cleanupReport;
                                showTemporaryMessage(
                                    `ğŸ†˜ ç´§æ€¥æ¸…ç†æˆåŠŸ: åˆ é™¤ ${report.deletedDates.length} å¤©æ•°æ®ï¼Œä¼˜åŒ– ${report.compressedFiles} ä¸ªæ–‡ä»¶`, 
                                    'success'
                                );
                                return;
                            }
                        } catch (retryError) {
                            console.error('ç´§æ€¥æ¸…ç†ä¹Ÿå¤±è´¥:', retryError);
                        }
                        
                        // å¦‚æœæ¸…ç†ä»ç„¶å¤±è´¥ï¼Œæä¾›æ‰‹åŠ¨é€‰é¡¹
                        showTemporaryMessage(
                            'âš ï¸ æµè§ˆå™¨å­˜å‚¨ç©ºé—´ä¸¥é‡ä¸è¶³ï¼è¯·è€ƒè™‘ï¼š1) æ¸…ç†æµè§ˆå™¨æ•°æ® 2) åˆ é™¤æ—§å†…å®¹ 3) å‡çº§åˆ°äº‘ç«¯å­˜å‚¨', 
                            'error'
                        );
                        
                    } else if (error.message.includes('localStorage')) {
                        showTemporaryMessage('âŒ æµè§ˆå™¨å­˜å‚¨è¢«ç¦ç”¨ï¼Œè¯·æ£€æŸ¥éšç§è®¾ç½®æˆ–å°è¯•æ— ç—•æ¨¡å¼', 'error');
                    } else {
                        showTemporaryMessage('âŒ æ•°æ®ä¿å­˜å¤±è´¥: ' + error.message, 'error');
                    }
                    
                    storageManager.storageStats.syncStatus = 'error';
                }
            }, [scheduledPosts, user]);

            // åˆå§‹åŒ–ç”¨æˆ·è®¤è¯çŠ¶æ€å’Œè¿æ¥æ£€æŸ¥
            React.useEffect(() => {
                const initAuth = async () => {
                    if (!isSupabaseConfigured) {
                        setIsLoading(false);
                        console.log('âš™ï¸ Supabaseæœªé…ç½®ï¼Œä½¿ç”¨æœ¬åœ°æ¨¡å¼');
                        return;
                    }

                    try {
                        // 1. é¦–å…ˆæ£€æŸ¥äº‘ç«¯è¿æ¥çŠ¶æ€
                        console.log('ğŸ” å¯åŠ¨æ—¶æ£€æŸ¥äº‘ç«¯è¿æ¥...');
                        const connectionResult = await SupabaseService.checkConnection();
                        console.log('ğŸ”— è¿æ¥æ£€æŸ¥ç»“æœ:', connectionResult);
                        
                        if (connectionResult.status !== 'connected') {
                            console.warn('âš ï¸ äº‘ç«¯è¿æ¥å¼‚å¸¸:', connectionResult.message);
                            showTemporaryMessage(`âš ï¸ äº‘ç«¯è¿æ¥å¼‚å¸¸: ${connectionResult.message}`, 'warning');
                        } else {
                            console.log(`âœ… äº‘ç«¯è¿æ¥æ­£å¸¸ (${connectionResult.details.responseTime})`);
                        }

                        // 2. è·å–å½“å‰ç”¨æˆ·
                        const currentUser = await SupabaseService.getCurrentUser();
                        setUser(currentUser);

                        // å¦‚æœç”¨æˆ·å·²ç™»å½•ï¼ŒåªåŒæ­¥äº‘ç«¯æ–‡æ¡ˆï¼Œä¿æŒæœ¬åœ°æ–‡ä»¶
                        if (currentUser) {
                            const cloudTextPosts = await SupabaseService.loadTextOnlyPosts();
                            if (cloudTextPosts && Object.keys(cloudTextPosts).length > 0) {
                                // ç®€åŒ–åˆå¹¶ï¼šåªæ›´æ–°æ–‡æ¡ˆå’Œå¹³å°ï¼Œä¿æŒæ‰€æœ‰æœ¬åœ°æ–‡ä»¶
                                setScheduledPosts(prevPosts => {
                                    const mergedPosts = { ...prevPosts };
                                    
                                    Object.entries(cloudTextPosts).forEach(([date, cloudDayPosts]) => {
                                        cloudDayPosts.forEach((cloudPost, index) => {
                                            if (mergedPosts[date] && mergedPosts[date][index]) {
                                                // åªæ›´æ–°æ–‡æ¡ˆå’Œå¹³å°ï¼Œä¿ç•™æ‰€æœ‰æœ¬åœ°æ–‡ä»¶
                                                mergedPosts[date][index] = {
                                                    ...mergedPosts[date][index], // ä¿æŒåŸæœ‰æ•°æ®ï¼ˆåŒ…æ‹¬filesï¼‰
                                                    caption: cloudPost.caption,   // æ›´æ–°æ–‡æ¡ˆ
                                                    platforms: cloudPost.platforms // æ›´æ–°å¹³å°
                                                };
                                            } else {
                                                // æ–°çš„äº‘ç«¯æ–‡æ¡ˆæ•°æ®ï¼ˆæ— æ–‡ä»¶ï¼‰
                                                if (!mergedPosts[date]) mergedPosts[date] = [];
                                                mergedPosts[date][index] = {
                                                    ...cloudPost,
                                                    files: [] // äº‘ç«¯åªæœ‰æ–‡æ¡ˆï¼Œæ— æ–‡ä»¶
                                                };
                                            }
                                        });
                                    });
                                    
                                    return mergedPosts;
                                });
                                showTemporaryMessage('æ–‡æ¡ˆå·²åŒæ­¥ï¼ˆæ–‡ä»¶ä¿æŒæœ¬åœ°å­˜å‚¨ï¼‰', 'success');
                            } else {
                                showTemporaryMessage('å·²ç™»å½•ï¼Œæ–‡æ¡ˆå°†åŒæ­¥åˆ°äº‘ç«¯', 'success');
                            }
                        }
                    } catch (error) {
                        console.error('è®¤è¯åˆå§‹åŒ–å¤±è´¥:', error);
                    } finally {
                        setIsLoading(false);
                    }
                };

                initAuth();

                // ç›‘å¬è®¤è¯çŠ¶æ€å˜åŒ–
                if (isSupabaseConfigured) {
                    const { data: { subscription } } = supabase.auth.onAuthStateChange(
                        async (event, session) => {
                            setUser(session?.user || null);
                            
                            if (event === 'SIGNED_IN' && session?.user) {
                                showTemporaryMessage('ç™»å½•æˆåŠŸï¼æ­£åœ¨åŒæ­¥æ–‡æ¡ˆ...', 'success');
                                const cloudTextPosts = await SupabaseService.loadTextOnlyPosts();
                                if (cloudTextPosts && Object.keys(cloudTextPosts).length > 0) {
                                    // ç®€åŒ–åˆå¹¶ï¼šåªæ›´æ–°æ–‡æ¡ˆï¼Œä¿æŒæ‰€æœ‰æœ¬åœ°æ–‡ä»¶
                                    setScheduledPosts(prevPosts => {
                                        const mergedPosts = { ...prevPosts };
                                        
                                        Object.entries(cloudTextPosts).forEach(([date, cloudDayPosts]) => {
                                            cloudDayPosts.forEach((cloudPost, index) => {
                                                if (mergedPosts[date] && mergedPosts[date][index]) {
                                                    // åªæ›´æ–°æ–‡æ¡ˆå’Œå¹³å°ï¼Œä¿ç•™æ‰€æœ‰æœ¬åœ°æ–‡ä»¶
                                                    mergedPosts[date][index] = {
                                                        ...mergedPosts[date][index], // ä¿æŒåŸæœ‰æ•°æ®ï¼ˆåŒ…æ‹¬filesï¼‰
                                                        caption: cloudPost.caption,   // æ›´æ–°æ–‡æ¡ˆ
                                                        platforms: cloudPost.platforms // æ›´æ–°å¹³å°
                                                    };
                                                } else {
                                                    // æ–°çš„äº‘ç«¯æ–‡æ¡ˆæ•°æ®ï¼ˆæ— æ–‡ä»¶ï¼‰
                                                    if (!mergedPosts[date]) mergedPosts[date] = [];
                                                    mergedPosts[date][index] = {
                                                        ...cloudPost,
                                                        files: [] // äº‘ç«¯åªæœ‰æ–‡æ¡ˆï¼Œæ— æ–‡ä»¶
                                                    };
                                                }
                                            });
                                        });
                                        
                                        return mergedPosts;
                                    });
                                    showTemporaryMessage('æ–‡æ¡ˆåŒæ­¥å®Œæˆï¼ˆæ–‡ä»¶ä¿æŒæœ¬åœ°ï¼‰', 'success');
                                } else {
                                    showTemporaryMessage('ç™»å½•æˆåŠŸï¼æ–‡æ¡ˆå°†åŒæ­¥åˆ°äº‘ç«¯', 'success');
                                }
                            } else if (event === 'SIGNED_OUT') {
                                showTemporaryMessage('å·²é€€å‡ºç™»å½•', 'success');
                            }
                        }
                    );

                    return () => subscription.unsubscribe();
                }
            }, []);

            // æ—¶é—´æ›´æ–°
            React.useEffect(() => {
                const timer = setInterval(() => {
                    setCurrentTime(new Date());
                }, 1000);
                return () => clearInterval(timer);
            }, []);

            // é”®ç›˜äº‹ä»¶
            React.useEffect(() => {
                const handleKeyDown = (event) => {
                    if (event.key === 'Escape' && lightboxMedia) {
                        closeLightbox();
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [lightboxMedia]);

            // è½®æ’­é€»è¾‘
            React.useEffect(() => {
                const intervals = {};
                Object.keys(scheduledPosts).forEach(dayKey => {
                    const posts = scheduledPosts[dayKey];
                    if (posts.length > 0 && posts[0].files && posts[0].files.length > 1) {
                        intervals[dayKey] = setInterval(() => {
                            setCarouselIndices(prev => {
                                const newIndex = ((prev[dayKey] || 0) + 1) % posts[0].files.length;
                                
                                // å½“è½®æ’­åˆ‡æ¢æ—¶ï¼Œé‡æ–°æ’­æ”¾è§†é¢‘
                                setTimeout(() => {
                                    const videos = document.querySelectorAll(`[data-day-key="${dayKey}"] video`);
                                    videos.forEach(video => {
                                        if (video.currentTime > 0 || video.paused) {
                                            video.currentTime = 0;
                                            video.play().catch(() => {
                                                // é™é»˜å¤„ç†æ’­æ”¾å¤±è´¥
                                            });
                                        }
                                    });
                                }, 100);
                                
                                return {
                                    ...prev,
                                    [dayKey]: newIndex
                                };
                            });
                        }, 5000); // å¢åŠ åˆ°5ç§’ï¼Œç»™è§†é¢‘æ›´å¤šæ’­æ”¾æ—¶é—´
                    }
                });
                return () => { 
                    Object.values(intervals).forEach(interval => clearInterval(interval)); 
                };
            }, [scheduledPosts]);

            const showTemporaryMessage = (text, type = 'success') => {
                    setMessage({ text, type });
                    setTimeout(() => setMessage({ text: '', type: '' }), 3000);
            };

            const getToday = () => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                return today;
            };

            const getDaysInMonth = (date) => {
                return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            };

            const getFirstDayOfMonth = (date) => {
                return new Date(date.getFullYear(), date.getMonth(), 1).getDay();
            };

            const getMonthYear = () => {
                return currentDate.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long' });
            };

            const prevMonth = () => {
                setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1));
            };

            const nextMonth = () => {
                setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1));
            };

            const openModal = (day) => {
                setSelectedDay(day);
                setShowModal(true);
                setSelectedFiles([]);
                setSelectedPlatforms([]);
                setCaptionInput('');
            };

            const closeModal = () => {
                setShowModal(false);
                setSelectedDay(null);
                setSelectedFiles([]);
                setSelectedPlatforms([]);
                setCaptionInput('');
            };

            const openLightbox = (media) => {
                console.log('OpenLightbox called with:', media);
                
                // ğŸ¥ æ™ºèƒ½æ’­æ”¾æºé€‰æ‹©ï¼šäº‘ç«¯ä¼˜å…ˆç­–ç•¥
                let playbackUrl = media.dataUrl;
                
                // ä¼˜å…ˆçº§ï¼šäº‘ç«¯URL > åŸå§‹DataURL > æ™®é€šDataURL
                if (media.cloudUrl) {
                    playbackUrl = media.cloudUrl;
                    console.log('ğŸŒ ä½¿ç”¨äº‘ç«¯URLæ’­æ”¾:', media.cloudUrl);
                } else if (media.originalDataUrl) {
                    playbackUrl = media.originalDataUrl;
                    console.log('ğŸ“ ä½¿ç”¨åŸå§‹DataURLæ’­æ”¾');
                } else if (media.dataUrl) {
                    playbackUrl = media.dataUrl;
                    console.log('ğŸ’¾ ä½¿ç”¨ç¼“å­˜DataURLæ’­æ”¾');
                }
                
                const processedMedia = {
                    ...media,
                    dataUrl: playbackUrl,
                    type: media.type || (media.name && media.name.includes('.mp4') ? 'video' : 'image'),
                    isCloudBased: !!media.cloudUrl // æ ‡è®°æ˜¯å¦ä¸ºäº‘ç«¯æ–‡ä»¶
                };
                
                console.log('Processed media for lightbox:', processedMedia);
                console.log('Using playback URL:', playbackUrl?.substring(0, 50) + '...');
                
                setLightboxMedia(processedMedia);
                setCurrentLightboxIndex(media.currentIndex || 0);
            };

            const closeLightbox = () => {
                setLightboxMedia(null);
            };

            // å¿«é€Ÿå‘å¸ƒåŠŸèƒ½
            const quickPublish = (platform) => {
                const today = getToday().toISOString().split('T')[0];
                const todaysPosts = scheduledPosts[today] || [];
                
                if (todaysPosts.length === 0) {
                    showTemporaryMessage('ä»Šæ—¥æ²¡æœ‰å¾…å‘å¸ƒçš„å†…å®¹', 'error');
                        return;
                    }

                const post = todaysPosts[0];
                const caption = post.caption || '';
                
                // å¹³å°å‘å¸ƒé¡µé¢URL
                const publishUrls = {
                    'IG': 'https://www.instagram.com/',
                    'FB': 'https://www.facebook.com/',
                    'å°çº¢ä¹¦': 'https://www.xiaohongshu.com/explore',
                    'æŠ–éŸ³': 'https://www.douyin.com/',
                    'å¾®åš': 'https://weibo.com/u/page/publish',
                    'å¾®ä¿¡': 'https://mp.weixin.qq.com/'
                };

                // å¤åˆ¶æ–‡æ¡ˆåˆ°å‰ªè´´æ¿
                if (caption) {
                    navigator.clipboard.writeText(caption).then(() => {
                        showTemporaryMessage(`æ–‡æ¡ˆå·²å¤åˆ¶ï¼Œæ­£åœ¨è·³è½¬åˆ°${platform}`, 'success');
                        setTimeout(() => {
                            window.open(publishUrls[platform], '_blank');
                        }, 1000);
                    }).catch(() => {
                        showTemporaryMessage('å¤åˆ¶å¤±è´¥ï¼Œä½†ä»ä¼šè·³è½¬åˆ°å‘å¸ƒé¡µé¢', 'error');
                        window.open(publishUrls[platform], '_blank');
                    });
                    } else {
                    window.open(publishUrls[platform], '_blank');
                }
            };

            // å¯¼å‡ºä»Šæ—¥å†…å®¹
            const exportTodayContent = () => {
                const today = getToday().toISOString().split('T')[0];
                const todaysPosts = scheduledPosts[today] || [];
                
                if (todaysPosts.length === 0) {
                    showTemporaryMessage('ä»Šæ—¥æ²¡æœ‰å¾…å‘å¸ƒçš„å†…å®¹', 'error');
                    return;
                }

                let content = `ğŸ“… ${today} å‘å¸ƒå†…å®¹\\n\\n`;
                
                todaysPosts.forEach((post, index) => {
                    content += `ã€ç¬¬${index + 1}æ¡ã€‘\\n`;
                    content += `å¹³å°ï¼š${post.platforms.join('ã€')}\\n`;
                    if (post.caption) {
                        content += `æ–‡æ¡ˆï¼š${post.caption}\\n`;
                    }
                    if (post.files && post.files.length > 0) {
                        content += `åª’ä½“ï¼š${post.files.length}ä¸ªæ–‡ä»¶\\n`;
                    }
                    content += '\\n';
                });

                // å¤åˆ¶åˆ°å‰ªè´´æ¿
                navigator.clipboard.writeText(content).then(() => {
                    showTemporaryMessage('ä»Šæ—¥å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                }).catch(() => {
                    showTemporaryMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
                });
            };

            const handleFileChange = (event) => {
                const files = Array.from(event.target.files);
                const validFiles = files.filter(file => {
                    if (!file.type.startsWith('image/') && !file.type.startsWith('video/')) {
                        showTemporaryMessage(`æ–‡ä»¶ ${file.name} ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æˆ–è§†é¢‘æ–‡ä»¶ã€‚`, 'error');
                        return false;
                    }
                    return true;
                });
                setSelectedFiles(prevFiles => [...prevFiles, ...validFiles]);
            };

            const removeSelectedFile = (indexToRemove) => {
                setSelectedFiles(prevFiles => prevFiles.filter((_, index) => index !== indexToRemove));
            };

            const handlePlatformChange = (platformName) => {
                setSelectedPlatforms(prevPlatforms => {
                    if (prevPlatforms.includes(platformName)) {
                        return prevPlatforms.filter(p => p !== platformName);
                } else {
                        return [...prevPlatforms, platformName];
                    }
                });
            };

            const removeMedia = (day, indexToRemove) => {
                const dayKey = day.toISOString().split('T')[0];
                setScheduledPosts(prevPosts => {
                    const updatedPosts = { ...prevPosts };
                    if (updatedPosts[dayKey]) {
                        updatedPosts[dayKey] = updatedPosts[dayKey].filter((_, index) => index !== indexToRemove);
                        if (updatedPosts[dayKey].length === 0) {
                            delete updatedPosts[dayKey];
                        }
                    }
                    return updatedPosts;
                });
                showTemporaryMessage('å†…å®¹å·²åˆ é™¤ã€‚', 'error');
            };

            const compressImage = (file, maxWidth = 1920, quality = 0.8) => {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = () => {
                        const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
                        canvas.width = img.width * ratio;
                        canvas.height = img.height * ratio;
                        
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    };
                    
                    img.src = URL.createObjectURL(file);
                });
            };

            const createVideoThumbnail = (file) => {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        video.currentTime = 1;
                    };
                    
                    video.onseeked = () => {
                        ctx.drawImage(video, 0, 0);
                        resolve(canvas.toDataURL('image/jpeg', 0.8));
                    };
                    
                    video.onerror = () => reject(new Error('è§†é¢‘åŠ è½½å¤±è´¥'));
                    video.src = URL.createObjectURL(file);
                });
            };

            const compressVideo = (file) => {
                return new Promise((resolve, reject) => {
                    // å¯¹äºè§†é¢‘æ–‡ä»¶ï¼Œæˆ‘ä»¬å°è¯•ç›´æ¥è½¬æ¢ä¸ºDataURL
                    // æœ¬åœ°å­˜å‚¨æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬å°½é‡ä¿å­˜å®Œæ•´è§†é¢‘
                    const maxSize = 100 * 1024 * 1024; // æé«˜åˆ°100MBé™åˆ¶ï¼Œé€‚åº”æœ¬åœ°å­˜å‚¨
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const dataUrl = e.target.result;
                        console.log(`è§†é¢‘è½¬æ¢ä¸ºDataURLæˆåŠŸ: ${file.name}, å¤§å°: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
                        resolve(dataUrl);
                    };
                    reader.onerror = () => {
                        console.error('è§†é¢‘è¯»å–å¤±è´¥:', file.name);
                        reject(new Error('è§†é¢‘è¯»å–å¤±è´¥'));
                    };
                    
                    if (file.size <= maxSize) {
                        reader.readAsDataURL(file);
                    } else {
                        console.warn(`è§†é¢‘æ–‡ä»¶è¿‡å¤§ (${(file.size / 1024 / 1024).toFixed(2)} MB)ï¼Œå°†ä½¿ç”¨ç¼©ç•¥å›¾`);
                        reject(new Error('è§†é¢‘æ–‡ä»¶è¿‡å¤§ï¼Œå°†ä½¿ç”¨ç¼©ç•¥å›¾'));
                    }
                });
            };

            const addMediaToDay = async () => {
                if (selectedFiles.length === 0 && !captionInput.trim()) {
                    showTemporaryMessage('è¯·ä¸Šä¼ å›¾ç‰‡/è§†é¢‘æˆ–è¾“å…¥æ–‡æ¡ˆã€‚', 'error');
                    return;
                }
                if (selectedPlatforms.length === 0) {
                    showTemporaryMessage('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå‘å¸ƒå¹³å°ã€‚', 'error');
                    return;
                }

                const dayKey = selectedDay.toISOString().split('T')[0];
                const newPost = {
                    platforms: selectedPlatforms,
                    caption: captionInput.trim(),
                    files: []
                };

                if (selectedFiles.length > 0) {
                    try {
                        // ğŸš€ ä½¿ç”¨æ™ºèƒ½å­˜å‚¨ç®¡ç†å™¨å¤„ç†æ–‡ä»¶
                        console.log(`ğŸ“¦ å¼€å§‹å¤„ç† ${selectedFiles.length} ä¸ªæ–‡ä»¶...`);
                        
                        const filePromises = selectedFiles.map(async (file, index) => {
                            try {
                                if (uploadProgress) {
                                    setUploadProgress(prev => ({ ...prev, [file.name]: 0 }));
                                }
                                
                                console.log(`ğŸ“‚ å¤„ç†æ–‡ä»¶ ${index + 1}/${selectedFiles.length}: ${file.name}`);
                                
                                // ğŸ“¸ğŸ¬ æ˜¾ç¤ºå‹ç¼©è¿›åº¦
                                if (file.type.startsWith('video/') && file.size > 3 * 1024 * 1024) {
                                    showTemporaryMessage(`ğŸ¬ æ­£åœ¨å‹ç¼©è§†é¢‘: ${file.name}...`, 'info');
                                } else if (file.type.startsWith('image/') && file.size > 5 * 1024 * 1024) {
                                    showTemporaryMessage(`ğŸ“¸ æ­£åœ¨æ™ºèƒ½å‹ç¼©å¤§å›¾ç‰‡: ${file.name}...`, 'info');
                                }
                                
                                const processedFile = await storageManager.processFile(file);
                                
                                // æ˜¾ç¤ºå‹ç¼©ç»“æœ
                                if (processedFile.isCompressed) {
                                    const originalSize = (file.size / 1024 / 1024).toFixed(1);
                                    const compressedSize = processedFile.compressedSize || 'æœªçŸ¥';
                                    
                                    if (file.type.startsWith('video/')) {
                                        if (processedFile.uploadCompressed) {
                                            showTemporaryMessage(`ğŸš€ è§†é¢‘å‹ç¼©å®Œæˆï¼Œå°†ç›´ä¼ äº‘ç«¯: ${originalSize}MB â†’ ${compressedSize}`, 'success');
                                        } else {
                                            showTemporaryMessage(`âœ… è§†é¢‘å‹ç¼©å®Œæˆ: ${originalSize}MB â†’ ${compressedSize}`, 'success');
                                        }
                                    } else if (file.type.startsWith('image/') && processedFile.autoImageCompressed) {
                                        // ğŸ–¼ï¸ æ™ºèƒ½å›¾ç‰‡å‹ç¼©åé¦ˆ
                                        const compressionRatio = ((1 - parseFloat(compressedSize) / parseFloat(originalSize)) * 100).toFixed(1);
                                        showTemporaryMessage(
                                            `ğŸ“¸ å›¾ç‰‡æ™ºèƒ½å‹ç¼©å®Œæˆ: ${originalSize}MB â†’ ${compressedSize} (å‹ç¼©ç‡${compressionRatio}%)`, 
                                            'success'
                                        );
                                    }
                                }
                                
                                if (uploadProgress) {
                                    setUploadProgress(prev => ({ ...prev, [file.name]: 100 }));
                                }
                                
                                return processedFile;
                            } catch (error) {
                                console.error(`âŒ æ–‡ä»¶å¤„ç†å¤±è´¥: ${file.name}`, error);
                                return {
                                    type: file.type.startsWith('image/') ? 'image' : 'video',
                                    name: file.name,
                                    size: file.size,
                                    error: error.message,
                                    file: file
                                };
                            }
                        });
                        
                        const fileData = await Promise.all(filePromises);
                        newPost.files = fileData;
                        
                        // ğŸ“Š æ›´æ–°å­˜å‚¨ç»Ÿè®¡
                        const stats = storageManager.updateStats({ ...scheduledPosts, [dayKey]: [newPost] });
                        console.log('ğŸ“Š å­˜å‚¨ç»Ÿè®¡:', stats);
                        
                    } catch (error) {
                        console.error('âŒ æ–‡ä»¶æ‰¹é‡å¤„ç†å¤±è´¥:', error);
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰æˆåŠŸå¤„ç†çš„æ–‡ä»¶
                        const validFiles = newPost.files.filter(file => !file.error);
                        if (validFiles.length > 0) {
                            newPost.files = validFiles;
                            showTemporaryMessage(`âš ï¸ ${selectedFiles.length - validFiles.length} ä¸ªæ–‡ä»¶å¤„ç†å¤±è´¥ï¼Œ${validFiles.length} ä¸ªæ–‡ä»¶æˆåŠŸä¿å­˜`, 'warning');
                        } else {
                            showTemporaryMessage('âŒ æ‰€æœ‰æ–‡ä»¶å¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼å’Œå¤§å°', 'error');
                            return;
                        }
                    }
                }

                setScheduledPosts(prevPosts => {
                    const updatedPosts = { ...prevPosts };
                    if (!updatedPosts[dayKey]) {
                        updatedPosts[dayKey] = [];
                    }
                    updatedPosts[dayKey].push(newPost);
                    return updatedPosts;
                });

                showTemporaryMessage('å†…å®¹å·²æ·»åŠ åˆ°æ—¥å†ï¼', 'success');
                closeModal();
            };

            const renderCalendarDays = () => {
                const totalDays = getDaysInMonth(currentDate);
                const firstDayIndex = getFirstDayOfMonth(currentDate);
                const days = [];
                const today = getToday();

                for (let i = 0; i < firstDayIndex; i++) {
                    days.push(
                        <div key={`empty-${i}`} className="flex flex-col">
                            <div className="aspect-9-16 calendar-cell bg-white"></div>
                            <div className="flex justify-center py-2">
                                <span className="text-transparent text-sm">+</span>
                            </div>
                        </div>
                    );
                }

                for (let day = 1; day <= totalDays; day++) {
                    const currentDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), day);
                    currentDay.setHours(0, 0, 0, 0);
                    const dayKey = currentDay.toISOString().split('T')[0];
                    const postsForDay = scheduledPosts[dayKey] || [];

                    let cellClass = 'calendar-cell bg-white';
                    if (currentDay.getTime() === today.getTime()) {
                        cellClass = 'calendar-cell today-cell';
                    } else if (currentDay.getTime() < today.getTime()) {
                        cellClass = 'calendar-cell past-cell';
                    }

                    days.push(
                        <div key={dayKey} className="flex flex-col">
                            <div className={`relative ${cellClass} aspect-9-16`} data-day-key={dayKey}>
                                <div className="absolute top-2 left-2 text-xs text-gray-400 z-10" style={{fontWeight: 300}}>{day}</div>
                                
                                {postsForDay.length > 0 ? (
                                    postsForDay[0].files && postsForDay[0].files.length > 0 ? (
                                        <div className="relative group media-container">
                                            <button
                                                onClick={() => removeMedia(currentDay, 0)}
                                                className="absolute top-2 right-2 z-20 opacity-0 group-hover:opacity-100 transition-opacity bg-blue-500 text-white rounded-full p-1 shadow-md hover:bg-blue-600"
                                                title="åˆ é™¤å†…å®¹"
                                            >
                                                <XCircle />
                                            </button>
                                            
                                            {/* å¤šä¸ªæ–‡ä»¶æ—¶æ˜¾ç¤ºè½®æ’­æŒ‡ç¤ºå™¨ */}
                                            {postsForDay[0].files.length > 1 && (
                                                <div className="absolute bottom-2 left-1/2 transform -translate-x-1/2 z-10 flex space-x-1 bg-black bg-opacity-30 px-2 py-1 rounded-full">
                                                    {postsForDay[0].files.map((_, index) => (
                                                        <div
                                                            key={index}
                                                            className={`w-1.5 h-1.5 rounded-full ${
                                                                index === (carouselIndices[dayKey] || 0) 
                                                                    ? 'bg-white' 
                                                                    : 'bg-white bg-opacity-50'
                                                            }`}
                                                        />
                                                    ))}
                                                </div>
                                            )}
                                            
                                            {(() => {
                                                const currentFileIndex = carouselIndices[dayKey] || 0;
                                                const currentFile = postsForDay[0].files[currentFileIndex];
                                                
                                                if (currentFile.type === 'image') {
                                                    return (
                                                        <img
                                                            src={currentFile.dataUrl || currentFile.originalDataUrl}
                                                            alt="å†…å®¹å›¾ç‰‡"
                                                            className="cursor-pointer"
                                                            onClick={() => openLightbox({
                                                                ...currentFile,
                                                                // å¯¹äºå›¾ç‰‡ï¼Œä½¿ç”¨é«˜è´¨é‡çš„originalDataUrlæˆ–cloudUrl
                                                                dataUrl: currentFile.cloudUrl || currentFile.originalDataUrl || currentFile.dataUrl,
                                                                caption: postsForDay[0].caption,
                                                                allFiles: postsForDay[0].files,
                                                                currentIndex: currentFileIndex
                                                            })}
                                                        />
                                                    );
                                                } else {
                                                    return (
                                                        <div 
                                                            className="w-full h-full cursor-pointer"
                                                            onClick={() => openLightbox({
                                                                ...currentFile,
                                                                // å¯¹äºè§†é¢‘ï¼Œä¿æŒcloudUrlç”¨äºæ’­æ”¾
                                                                dataUrl: currentFile.cloudUrl || currentFile.originalDataUrl || currentFile.dataUrl,
                                                                caption: postsForDay[0].caption,
                                                                allFiles: postsForDay[0].files,
                                                                currentIndex: currentFileIndex
                                                            })}
                                                        >
                                                            {/* ç®€åŒ–çš„è§†é¢‘æ˜¾ç¤ºï¼šç›´æ¥ä½¿ç”¨DataURL */}
                                                            {currentFile.dataUrl && currentFile.dataUrl.startsWith('data:video/') ? (
                                                                <video
                                                                    src={currentFile.dataUrl}
                                                                    className="w-full h-full object-cover calendar-video"
                                                                    autoPlay
                                                                    muted
                                                                    loop
                                                                    playsInline
                                                                    preload="metadata"
                                                                    onClick={(e) => e.stopPropagation()}
                                                                    onError={(e) => {
                                                                        console.error('è§†é¢‘æ’­æ”¾å¤±è´¥:', currentFile.name);
                                                                    }}
                                                                    onLoadedData={() => {
                                                                        if (DEBUG_MODE) console.log('è§†é¢‘æ’­æ”¾æˆåŠŸ:', currentFile.name);
                                                                    }}
                                                                />
                                                            ) : currentFile.thumbnail ? (
                                                                <div className="w-full h-full relative">
                                                                    <img
                                                                        src={currentFile.thumbnail}
                                                                        alt="è§†é¢‘ç¼©ç•¥å›¾"
                                                                        className="w-full h-full object-cover"
                                                                    />
                                                                    <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-20">
                                                                        <div className="bg-white bg-opacity-90 rounded-full p-2">
                                                                            <span className="text-gray-700 text-xl">â–¶</span>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            ) : (
                                                                <div className="w-full h-full bg-gray-200 flex items-center justify-center">
                                                                    <div className="text-center">
                                                                        <span className="text-4xl">ğŸ¥</span>
                                                                        <div className="text-xs text-gray-500 mt-1">è§†é¢‘åŠ è½½ä¸­</div>
                                                                    </div>
                                            </div>
                                        )}

                                        </div>
                                                    );
                                                }
                                            })()}
                                        </div>
                                    ) : (
                                        postsForDay[0].caption && (
                                            <div className="relative group w-full h-full">
                                            <button
                                                    onClick={() => removeMedia(currentDay, 0)}
                                                    className="absolute top-2 right-2 z-20 opacity-0 group-hover:opacity-100 transition-opacity bg-blue-500 text-white rounded-full p-1 shadow-md hover:bg-blue-600"
                                                title="åˆ é™¤å†…å®¹"
                                            >
                                                    <XCircle size={12} />
                                            </button>
                                                
                                                <div 
                                                    className="w-full h-full p-3 cursor-pointer bg-gradient-to-br from-blue-50 to-indigo-50 border border-blue-100 hover:from-blue-100 hover:to-indigo-100 transition-colors flex items-center justify-center"
                                                    onClick={() => openLightbox({
                                                        type: 'text',
                                                        caption: postsForDay[0].caption
                                                    })}
                                                >
                                                    <p className="text-gray-700 text-xs leading-relaxed text-center line-clamp-6 font-medium">
                                                        {postsForDay[0].caption.length > 60 
                                                            ? postsForDay[0].caption.substring(0, 60) + '...' 
                                                            : postsForDay[0].caption
                                                        }
                                                    </p>
                                        </div>
                                    </div>
                                        )
                                    )
                                ) : null}
                            </div>
                            
                            <div className="flex justify-center py-2">
                            <button
                                onClick={() => openModal(currentDay)}
                                    className="text-gray-300 hover:text-gray-500 transition-colors text-sm"
                                    title="æ·»åŠ å†…å®¹"
                            >
                                    +
                            </button>
                            </div>
                        </div>
                    );
                }
                return days;
            };

            // ğŸ”— äº‘ç«¯è¿æ¥æ£€æŸ¥ç»„ä»¶
            const ConnectionChecker = ({ showTemporaryMessage }) => {
                const [connectionStatus, setConnectionStatus] = React.useState(null);
                const [isChecking, setIsChecking] = React.useState(false);

                const checkConnection = async () => {
                    setIsChecking(true);
                    showTemporaryMessage('ğŸ” æ­£åœ¨æ£€æŸ¥äº‘ç«¯è¿æ¥...', 'info');
                    
                    try {
                        const result = await SupabaseService.checkConnection();
                        setConnectionStatus(result);
                        
                        if (result.status === 'connected') {
                            showTemporaryMessage(`âœ… ${result.message} (${result.details.responseTime})`, 'success');
                        } else {
                            showTemporaryMessage(`âŒ ${result.message}: ${result.details}`, 'error');
                        }
                    } catch (error) {
                        showTemporaryMessage('âŒ è¿æ¥æ£€æŸ¥å¤±è´¥', 'error');
                    } finally {
                        setIsChecking(false);
                    }
                };

                const getStatusIcon = () => {
                    if (isChecking) return 'ğŸ”„';
                    if (!connectionStatus) return 'ğŸ”—';
                    
                    switch (connectionStatus.status) {
                        case 'connected': return 'âœ…';
                        case 'not_configured': return 'âš™ï¸';
                        case 'connection_error': return 'âŒ';
                        case 'database_error': return 'ğŸ—„ï¸';
                        default: return 'â“';
                    }
                };

                const getStatusColor = () => {
                    if (isChecking) return 'text-blue-500';
                    if (!connectionStatus) return 'text-gray-500';
                    
                    switch (connectionStatus.status) {
                        case 'connected': return 'text-green-500';
                        case 'not_configured': return 'text-orange-500';
                        case 'connection_error': 
                        case 'database_error': 
                        case 'error': return 'text-red-500';
                        default: return 'text-gray-500';
                    }
                };

                return (
                    <button
                        onClick={checkConnection}
                        disabled={isChecking}
                        className={`flex items-center gap-1 px-2 py-1 text-xs rounded hover:bg-gray-100 transition-colors ${getStatusColor()}`}
                        title="æ£€æŸ¥äº‘ç«¯è¿æ¥çŠ¶æ€"
                    >
                        <span className="text-sm">{getStatusIcon()}</span>
                        <span>{isChecking ? 'æ£€æŸ¥ä¸­...' : 'è¿æ¥æ£€æŸ¥'}</span>
                    </button>
                );
            };

            // ğŸ“Š æ™ºèƒ½å­˜å‚¨ç®¡ç†ç»„ä»¶
            const StorageStatusDisplay = () => {
                const [storageStats, setStorageStats] = React.useState(storageManager.storageStats);
                const [showManagement, setShowManagement] = React.useState(false);
                const [isCleaningUp, setIsCleaningUp] = React.useState(false);
                
                React.useEffect(() => {
                    const interval = setInterval(() => {
                        setStorageStats({...storageManager.storageStats});
                    }, 1000);
                    return () => clearInterval(interval);
                }, []);
                
                const formatSize = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };
                
                const getSyncStatusIcon = () => {
                    switch (storageStats.syncStatus) {
                        case 'syncing': return 'ğŸ”„';
                        case 'success': return 'âœ…';
                        case 'error': return 'âŒ';
                        default: return 'ğŸ’¾';
                    }
                };
                
                const getSyncStatusText = () => {
                    switch (storageStats.syncStatus) {
                        case 'syncing': return 'åŒæ­¥ä¸­';
                        case 'success': return 'å·²åŒæ­¥';
                        case 'error': return 'åŒæ­¥å¤±è´¥';
                        default: return 'æœ¬åœ°å­˜å‚¨';
                    }
                };
                
                // æ£€æŸ¥å­˜å‚¨ç©ºé—´ä½¿ç”¨ç‡
                const getStorageUsageColor = () => {
                    const usage = storageStats.localSize / (10 * 1024 * 1024); // å‡è®¾10MBä¸ºæ»¡å®¹é‡
                    if (usage > 0.8) return 'text-red-500';
                    if (usage > 0.6) return 'text-yellow-500';
                    return 'text-green-500';
                };
                
                const getStorageUsagePercent = () => {
                    const usage = storageStats.localSize / (10 * 1024 * 1024);
                    return Math.min(Math.round(usage * 100), 100);
                };
                
                // æ‰‹åŠ¨æ¸…ç†å­˜å‚¨
                const handleManualCleanup = async (aggressive = false) => {
                    setIsCleaningUp(true);
                    try {
                        const cleanupOptions = aggressive ? 
                            { maxSizeMB: 2, maxAgeDays: 7, aggressive: true } :
                            { maxSizeMB: 5, maxAgeDays: 30, aggressive: false };
                            
                        const cleanupResult = storageManager.cleanupStorage({...scheduledPosts}, cleanupOptions);
                        
                        if (cleanupResult.cleaned) {
                            setScheduledPosts(cleanupResult.posts);
                            localStorage.setItem('socialMediaCalendar', JSON.stringify(cleanupResult.posts));
                            
                            const report = cleanupResult.cleanupReport;
                            const freedMB = (report.freedSpace / (1024 * 1024)).toFixed(1);
                            showTemporaryMessage(
                                `ğŸ§¹ æ‰‹åŠ¨æ¸…ç†å®Œæˆ: é‡Šæ”¾ ${freedMB}MBï¼Œå¤„ç† ${report.compressedFiles + report.deletedFiles} ä¸ªæ–‡ä»¶`,
                                'success'
                            );
                        } else {
                            showTemporaryMessage('â„¹ï¸ å½“å‰æ•°æ®å·²ç»æ¯”è¾ƒç²¾ç®€ï¼Œæ— éœ€æ¸…ç†', 'info');
                        }
                    } catch (error) {
                        console.error('æ‰‹åŠ¨æ¸…ç†å¤±è´¥:', error);
                        showTemporaryMessage('âŒ æ¸…ç†å¤±è´¥: ' + error.message, 'error');
                    } finally {
                        setIsCleaningUp(false);
                        setShowManagement(false);
                    }
                };
                
                // æ¸…ç©ºæ‰€æœ‰æ•°æ®
                const handleClearAllData = () => {
                    if (confirm('âš ï¸ ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æœ¬åœ°æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
                        const success = storageManager.clearAllData();
                        if (success) {
                            setScheduledPosts({});
                            showTemporaryMessage('ğŸ—‘ï¸ æ‰€æœ‰æœ¬åœ°æ•°æ®å·²æ¸…ç©º', 'success');
                            setShowManagement(false);
                        } else {
                            showTemporaryMessage('âŒ æ¸…ç©ºæ•°æ®å¤±è´¥', 'error');
                        }
                    }
                };

                return (
                    <div className="fixed bottom-4 left-4 z-40 bg-white rounded-lg shadow-lg border text-xs max-w-xs">
                        <div className="p-3">
                            <div className="flex items-center gap-2 mb-2">
                                <span className="text-lg">{getSyncStatusIcon()}</span>
                                <span className="font-medium">{getSyncStatusText()}</span>
                                
                                {/* ç®¡ç†æŒ‰é’® */}
                                <button
                                    onClick={() => setShowManagement(!showManagement)}
                                    className="ml-auto text-gray-400 hover:text-gray-600 transition-colors"
                                    title="å­˜å‚¨ç®¡ç†"
                                >
                                    âš™ï¸
                                </button>
                            </div>
                            
                            <div className="space-y-1 text-gray-600">
                                <div>ğŸ“ {storageStats.totalFiles} ä¸ªæ–‡ä»¶</div>
                                <div className="flex items-center gap-2">
                                    ğŸ’¾ æœ¬åœ°: <span className={getStorageUsageColor()}>{formatSize(storageStats.localSize)}</span>
                                    <span className="text-xs text-gray-400">({getStorageUsagePercent()}%)</span>
                                </div>
                                {storageStats.cloudSize > 0 && (
                                    <div>â˜ï¸ äº‘ç«¯: {formatSize(storageStats.cloudSize)}</div>
                                )}
                                
                                {/* å­˜å‚¨ç©ºé—´è­¦å‘Š */}
                                {storageStats.localSize > 8 * 1024 * 1024 && (
                                    <div className="text-red-500 text-xs mt-1 font-medium">
                                        âš ï¸ å­˜å‚¨ç©ºé—´ä¸¥é‡ä¸è¶³
                                    </div>
                                )}
                            </div>
                            
                            {/* é”™è¯¯çŠ¶æ€ä¸‹æ˜¾ç¤ºæ›´å¤šä¿¡æ¯ */}
                            {storageStats.syncStatus === 'error' && (
                                <div className="mt-2 pt-2 border-t text-xs text-red-500">
                                    ğŸ’¡ æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ‰‹åŠ¨æ¸…ç†å­˜å‚¨
                                </div>
                            )}
                        </div>
                        
                        {/* å­˜å‚¨ç®¡ç†é¢æ¿ */}
                        {showManagement && (
                            <div className="border-t p-3 bg-gray-50">
                                <div className="text-xs font-medium text-gray-700 mb-2">å­˜å‚¨ç®¡ç†</div>
                                <div className="space-y-2">
                                    <button
                                        onClick={() => handleManualCleanup(false)}
                                        disabled={isCleaningUp}
                                        className="w-full px-2 py-1 bg-blue-100 hover:bg-blue-200 text-blue-700 rounded text-xs disabled:opacity-50"
                                    >
                                        {isCleaningUp ? 'ğŸ”„ æ¸…ç†ä¸­...' : 'ğŸ§¹ æ™ºèƒ½æ¸…ç†'}
                                    </button>
                                    <button
                                        onClick={() => handleManualCleanup(true)}
                                        disabled={isCleaningUp}
                                        className="w-full px-2 py-1 bg-orange-100 hover:bg-orange-200 text-orange-700 rounded text-xs disabled:opacity-50"
                                    >
                                        {isCleaningUp ? 'ğŸ”„ æ¸…ç†ä¸­...' : 'ğŸ”¥ æ·±åº¦æ¸…ç†'}
                                    </button>
                                    <button
                                        onClick={handleClearAllData}
                                        disabled={isCleaningUp}
                                        className="w-full px-2 py-1 bg-red-100 hover:bg-red-200 text-red-700 rounded text-xs disabled:opacity-50"
                                    >
                                        ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰æ•°æ®
                                    </button>
                                </div>
                                <div className="text-xs text-gray-500 mt-2">
                                    <div>â€¢ æ™ºèƒ½æ¸…ç†ï¼šä¿ç•™30å¤©æ•°æ®</div>
                                    <div>â€¢ æ·±åº¦æ¸…ç†ï¼šä»…ä¿ç•™7å¤©æ•°æ®</div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

                return (
                <div className="min-h-screen bg-gray-50 p-4 md:p-6 font-sans antialiased">
                    <div className="max-w-7xl mx-auto bg-white relative">
                        


                        {/* é¡¶éƒ¨æ§åˆ¶æ  */}
                        <div className="flex justify-between items-start p-4 md:p-8 pb-4">
                            {/* å·¦ä¾§ï¼šSupabaseçŠ¶æ€å’Œè®¤è¯ */}
                            <div className="text-sm text-gray-600">
                                {isSupabaseConfigured ? (
                                    <div className="flex items-center gap-4">
                                        {user ? (
                                            <div className="flex items-center gap-2">
                                                <span className="text-green-600">ğŸŸ¢</span>
                                                <span>äº‘ç«¯åŒæ­¥å·²å¼€å¯</span>
                                                <ConnectionChecker showTemporaryMessage={showTemporaryMessage} />
                                                <button
                                                    onClick={async () => {
                                                        await SupabaseService.signOut();
                                                    }}
                                                    className="text-xs px-2 py-1 bg-red-50 text-red-600 rounded hover:bg-red-100 transition-colors"
                                                >
                                                    é€€å‡º
                                                </button>
                                            </div>
                                        ) : (
                                            <div className="flex items-center gap-2">
                                                <span className="text-orange-600">ğŸŸ¡</span>
                                                <span>æœ¬åœ°å­˜å‚¨</span>
                                                <ConnectionChecker showTemporaryMessage={showTemporaryMessage} />
                                                <AuthModal showTemporaryMessage={showTemporaryMessage} />
                                                            </div>
                                                        )}
                                    </div>
                                ) : (
                                    <div className="flex items-center gap-2">
                                        <span className="text-gray-400">âš«</span>
                                        <span className="text-xs text-gray-500">
                                            æœ¬åœ°æ¨¡å¼ï¼ˆéœ€é…ç½®Supabaseå¯ç”¨äº‘ç«¯åŒæ­¥ï¼‰
                                                                </span>
                                                        </div>
                                )}
                            </div>
                            
                            {/* å³ä¾§ï¼šç°æœ‰æ§åˆ¶æŒ‰é’® */}
                            <div className="text-sm text-gray-600 font-medium text-right">
                                <div className="flex flex-col items-end gap-2 mb-4">
                                    {/* ä»Šæ—¥å†…å®¹å¿«é€Ÿå‘å¸ƒæŒ‰é’® */}
                                    <div className="flex gap-2 mb-2">
                                                            <button
                                            onClick={exportTodayContent}
                                            className="text-xs px-2 py-1 bg-purple-50 text-purple-600 rounded hover:bg-purple-100 transition-colors"
                                            title="å¤åˆ¶ä»Šæ—¥å‘å¸ƒå†…å®¹"
                                        >
                                            ğŸ“‹ ä»Šæ—¥å†…å®¹
                                                            </button>
                                                        </div>
                                    
                                    {/* å¿«é€Ÿå‘å¸ƒæŒ‰é’® */}
                                    {(() => {
                                        const today = getToday().toISOString().split('T')[0];
                                        const todaysPosts = scheduledPosts[today] || [];
                                        if (todaysPosts.length > 0 && todaysPosts[0].platforms) {
                                            return (
                                                <div className="flex gap-1 mb-2 flex-wrap justify-end">
                                                    {todaysPosts[0].platforms.map(platform => (
                                                        <button
                                                            key={platform}
                                                            onClick={() => quickPublish(platform)}
                                                            className="text-xs px-2 py-1 bg-blue-50 text-blue-600 rounded hover:bg-blue-100 transition-colors"
                                                            title={`å¿«é€Ÿå‘å¸ƒåˆ°${platform}`}
                                                        >
                                                            ğŸš€ {platform}
                                                        </button>
                        ))}
                    </div>
                );
                                        }
                                        return null;
                                    })()}
                                    
                                    <div className="text-xs text-gray-500">
                                        å­˜å‚¨: {Object.keys(scheduledPosts).length} ä¸ªæ—¥æœŸ
                                    </div>
                                </div>
                            {currentTime.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' })}
                            <br />
                            {currentTime.toLocaleTimeString('zh-CN')}
                            </div>
                        </div>

                        {/* ä¸»è¦å†…å®¹åŒºåŸŸ */}
                        <div className="px-4 md:px-8 pb-4 md:pb-8">

                        {message.text && (
                            <div className={`p-3 mb-4 rounded-lg text-center font-medium ${message.type === 'success' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                                {message.text}
                            </div>
                        )}

                        <div className="flex items-center justify-center mb-8 gap-3">
                                <button
                                    onClick={prevMonth}
                                className="nav-button flex items-center justify-center w-12 h-12 text-gray-500 hover:text-gray-700 hover:bg-gray-100 transition-all text-2xl font-light rounded-full"
                                    aria-label="ä¸Šä¸ªæœˆ"
                                >
                                <ChevronLeft />
                                </button>
                            <h2 className="text-3xl md:text-4xl lg:text-5xl text-gray-400 tracking-widest uppercase" style={{fontWeight: 200}}>
                                    {getMonthYear()}
                                </h2>
                                <button
                                    onClick={nextMonth}
                                className="nav-button flex items-center justify-center w-12 h-12 text-gray-500 hover:text-gray-700 hover:bg-gray-100 transition-all text-2xl font-light rounded-full"
                                    aria-label="ä¸‹ä¸ªæœˆ"
                                >
                                <ChevronRight />
                                </button>
                            </div>

                        <div className="grid grid-cols-7 gap-0 mb-4 text-center text-gray-400 text-sm tracking-wider">
                            {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, index) => (
                                <div key={index} className="py-4" style={{fontWeight: 300}}>{day}</div>
                                    ))}
                                </div>

                        <div className="grid grid-cols-7 gap-0">
                                    {renderCalendarDays()}
                    </div>

                        {/* æ·»åŠ å†…å®¹æ¨¡æ€æ¡† */}
                    {showModal && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                                <div className="bg-white rounded-lg max-w-md w-full p-6 max-h-[90vh] overflow-y-auto">
                                    <h2 className="text-xl font-bold mb-4">
                                        {selectedDay && `${selectedDay.getFullYear()}å¹´${selectedDay.getMonth() + 1}æœˆ${selectedDay.getDate()}æ—¥`}
                                    </h2>

                                <div className="mb-4">
                                        <label className="block text-sm font-medium text-gray-700 mb-2">é€‰æ‹©å¹³å°</label>
                                        <div className="flex flex-wrap gap-2">
                                            {platforms.map(platform => (
                                                <button
                                                    key={platform.name}
                                                    onClick={() => handlePlatformChange(platform.name)}
                                                    className={`px-3 py-1 text-sm rounded ${
                                                        selectedPlatforms.includes(platform.name)
                                                            ? 'bg-blue-500 text-white'
                                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                    }`}
                                                >
                                                    {platform.name}
                                                </button>
                                            ))}
                                            </div>
                                </div>

                                <div className="mb-4">
                                        <label className="block text-sm font-medium text-gray-700 mb-2">æ–‡æ¡ˆå†…å®¹</label>
                                    <textarea
                                        value={captionInput}
                                        onChange={(e) => setCaptionInput(e.target.value)}
                                            placeholder="è¾“å…¥å‘å¸ƒæ–‡æ¡ˆ..."
                                            className="w-full p-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                            rows="4"
                                        />
                                </div>

                                    <div className="mb-4">
                                        <label className="block text-sm font-medium text-gray-700 mb-2">ä¸Šä¼ å›¾ç‰‡/è§†é¢‘</label>
                                                <input
                                            type="file"
                                            multiple
                                            accept="image/*,video/*"
                                            onChange={handleFileChange}
                                            className="w-full p-2 border border-gray-300 rounded"
                                        />
                                    </div>

                                    {selectedFiles.length > 0 && (
                                        <div className="mb-4">
                                            <label className="block text-sm font-medium text-gray-700 mb-2">é¢„è§ˆæ–‡ä»¶</label>
                                            <div className="grid grid-cols-2 gap-2">
                                                {selectedFiles.map((file, index) => (
                                                    <div key={index} className="relative">
                                                        {file.type.startsWith('image/') ? (
                                                            <img
                                                                src={URL.createObjectURL(file)}
                                                                alt={file.name}
                                                                className="w-full h-20 object-cover rounded border cursor-pointer"
                                                                onClick={() => openLightbox({type: 'image', dataUrl: URL.createObjectURL(file), name: file.name})}
                                                            />
                                                        ) : (
                                                            <div
                                                                className="w-full h-20 bg-gray-100 rounded border flex items-center justify-center cursor-pointer"
                                                                onClick={() => openLightbox({type: 'video', dataUrl: URL.createObjectURL(file), name: file.name})}
                                                            >
                                                                <span className="text-2xl">ğŸ¥</span>
                                                            </div>
                                                        )}
                                                        <button
                                                            onClick={() => removeSelectedFile(index)}
                                                            className="absolute -top-2 -right-2 bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm hover:bg-blue-600"
                                                        >
                                                            Ã—
                                                        </button>
                                                        <div className="text-xs text-gray-500 mt-1 truncate">{file.name}</div>
                                                    </div>
                                        ))}
                                    </div>
                                </div>
                                    )}

                                    <div className="flex gap-3">
                                    <button
                                        onClick={closeModal}
                                            className="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition-colors"
                                    >
                                        å–æ¶ˆ
                                    </button>
                                    <button
                                        onClick={addMediaToDay}
                                            className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                                    >
                                            ä¿å­˜
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                        {/* Lightboxæ¨¡æ€æ¡† */}
                        {lightboxMedia && (
                            <div 
                                className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4"
                                onClick={closeLightbox}
                            >
                                <div className="flex max-w-7xl max-h-full w-full gap-6" onClick={(e) => e.stopPropagation()}>
                                    <button
                                        onClick={closeLightbox}
                                        className="absolute top-6 right-6 z-60 bg-white bg-opacity-20 text-white rounded-full p-2 hover:bg-opacity-30 transition-colors"
                                        title="å…³é—­"
                                    >
                                        <XCircle />
                                    </button>
                                    
                                    {/* åª’ä½“å†…å®¹åŒºåŸŸ */}
                                    <div className="flex-1 flex items-center justify-center relative">
                                        {/* å¤šæ–‡ä»¶æ—¶çš„å·¦å³åˆ‡æ¢æŒ‰é’® */}
                                        {lightboxMedia.allFiles && lightboxMedia.allFiles.length > 1 && (
                                            <>
                                                <button
                                                    onClick={() => {
                                                        const allFiles = lightboxMedia.allFiles;
                                                        const newIndex = (currentLightboxIndex - 1 + allFiles.length) % allFiles.length;
                                                        setCurrentLightboxIndex(newIndex);
                                                    }}
                                                    className="absolute left-4 z-50 bg-white bg-opacity-20 text-white rounded-full p-3 hover:bg-opacity-30 transition-colors"
                                                    title="ä¸Šä¸€ä¸ª"
                                                >
                                                    <ChevronLeft />
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        const allFiles = lightboxMedia.allFiles;
                                                        const newIndex = (currentLightboxIndex + 1) % allFiles.length;
                                                        setCurrentLightboxIndex(newIndex);
                                                    }}
                                                    className="absolute right-4 z-50 bg-white bg-opacity-20 text-white rounded-full p-3 hover:bg-opacity-30 transition-colors"
                                                    title="ä¸‹ä¸€ä¸ª"
                                                >
                                                    <ChevronRight />
                                                </button>
                                            </>
                                        )}

                                        {/* åª’ä½“æ˜¾ç¤ºåŒºåŸŸ */}
                                        {(() => {
                                            const currentMedia = lightboxMedia.allFiles ? 
                                                lightboxMedia.allFiles[currentLightboxIndex] : 
                                                lightboxMedia;
                                            
                                            if (currentMedia.type === 'image') {
                                                return (
                                                    <img
                                                        src={currentMedia.originalDataUrl || currentMedia.dataUrl}
                                                        alt={currentMedia.name}
                                                        className="max-w-full max-h-full object-contain rounded-lg"
                                                    />
                                                );
                                            } else if (currentMedia.type === 'video') {
                                                // æ™ºèƒ½é€‰æ‹©è§†é¢‘æºï¼šäº‘ç«¯URL > æœ¬åœ°å‹ç¼©è§†é¢‘ > åŸå§‹è§†é¢‘ > ç¼©ç•¥å›¾
                                                const videoSrc = currentMedia.cloudUrl ||  // ä¼˜å…ˆä½¿ç”¨äº‘ç«¯URL
                                                               (currentMedia.dataUrl && currentMedia.dataUrl.startsWith('data:video/') ? currentMedia.dataUrl : null) ||
                                                               (currentMedia.originalDataUrl && currentMedia.originalDataUrl.startsWith('data:video/') ? currentMedia.originalDataUrl : null) ||
                                                               (currentMedia.dataUrl && currentMedia.dataUrl.startsWith('blob:') ? currentMedia.dataUrl : null) ||
                                                               (currentMedia.originalDataUrl && currentMedia.originalDataUrl.startsWith('blob:') ? currentMedia.originalDataUrl : null);
                                                
                                                if (videoSrc) {
                                                    return (
                                                        <video
                                                            src={videoSrc}
                                                            controls
                                                            autoPlay
                                                            className="max-w-full max-h-full object-contain rounded-lg"
                                                            onError={(e) => {
                                                                console.error('è§†é¢‘åŠ è½½å¤±è´¥:', videoSrc);
                                                                // å¦‚æœäº‘ç«¯è§†é¢‘å¤±è´¥ï¼Œå°è¯•æœ¬åœ°è§†é¢‘
                                                                if (currentMedia.cloudUrl && (currentMedia.dataUrl || currentMedia.originalDataUrl)) {
                                                                    const fallbackSrc = (currentMedia.dataUrl && currentMedia.dataUrl.startsWith('data:video/')) ? 
                                                                                       currentMedia.dataUrl : currentMedia.originalDataUrl;
                                                                    if (fallbackSrc && fallbackSrc !== videoSrc) {
                                                                        e.target.src = fallbackSrc;
                                                                    }
                                                                }
                                                            }}
                                                        >
                                                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ ‡ç­¾ã€‚
                                                        </video>
                                                    );
                                                } else {
                                                    // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„è§†é¢‘æºï¼Œæ˜¾ç¤ºç¼©ç•¥å›¾
                                                    return (
                                                        <div className="flex flex-col items-center justify-center text-gray-400">
                                                            {currentMedia.thumbnail ? (
                                                                <img
                                                                    src={currentMedia.thumbnail}
                                                                    alt="è§†é¢‘ç¼©ç•¥å›¾"
                                                                    className="max-w-full max-h-full object-contain rounded-lg mb-4"
                                                                />
                                                            ) : (
                                                                <div className="text-8xl mb-4">ğŸ¥</div>
                                                            )}
                                                            <p className="text-lg">è§†é¢‘é¢„è§ˆä¸å¯ç”¨</p>
                                                            <p className="text-sm">æ–‡ä»¶ï¼š{currentMedia.name}</p>
                                                        </div>
                                                    );
                                                }
                                            } else {
                                                return (
                                                    <div className="flex items-center justify-center text-gray-400 text-xl">
                                                        ğŸ“ æ–‡å­—å†…å®¹
                                                    </div>
                                                );
                                            }
                                        })()}

                                        {/* è½®æ’­æŒ‡ç¤ºå™¨ */}
                                        {lightboxMedia.allFiles && lightboxMedia.allFiles.length > 1 && (
                                            <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 flex space-x-2">
                                                {lightboxMedia.allFiles.map((_, index) => (
                                                    <button
                                                        key={index}
                                                        onClick={() => setCurrentLightboxIndex(index)}
                                                        className={`w-3 h-3 rounded-full transition-colors ${
                                                            index === currentLightboxIndex 
                                                                ? 'bg-white' 
                                                                : 'bg-white bg-opacity-50 hover:bg-opacity-75'
                                                        }`}
                                                    />
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* å³ä¾§æ–‡å­—å†…å®¹åŒºåŸŸ */}
                                    <div className="w-80 bg-white rounded-lg p-6 flex flex-col max-h-full">
                                        <div className="flex items-center justify-between mb-4">
                                            <h3 className="text-lg font-semibold text-gray-800">æ–‡æ¡ˆå†…å®¹</h3>
                                            <button
                                                onClick={async () => {
                                                    try {
                                                        await navigator.clipboard.writeText(lightboxMedia.caption || '');
                                                        showTemporaryMessage('æ–‡æ¡ˆå·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                                                    } catch (err) {
                                                        showTemporaryMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
                                                    }
                                                }}
                                                className="px-3 py-1 bg-blue-500 text-white text-sm rounded-md hover:bg-blue-600 transition-colors flex items-center gap-1"
                                                title="å¤åˆ¶æ–‡æ¡ˆ"
                                            >
                                                ğŸ“‹ å¤åˆ¶
                                            </button>
                                        </div>
                                        
                                        {/* æ–‡æ¡ˆå†…å®¹ */}
                                        <div className="flex-1 overflow-y-auto border rounded-md p-4 bg-gray-50 mb-4">
                                            <p className="text-gray-700 leading-relaxed whitespace-pre-wrap text-base font-normal">
                                                {lightboxMedia.caption || 'æš‚æ— æ–‡æ¡ˆå†…å®¹'}
                                            </p>
                                        </div>

                                        {/* æ–‡ä»¶ä¿¡æ¯ */}
                                        <div className="border-t pt-4">
                                            <h4 className="text-sm font-medium text-gray-800 mb-2">
                                                æ–‡ä»¶ä¿¡æ¯ {lightboxMedia.allFiles ? `(${currentLightboxIndex + 1}/${lightboxMedia.allFiles.length})` : '(1/1)'}
                                            </h4>
                                            <div className="text-xs text-gray-600 space-y-1">
                                                {(() => {
                                                    const currentMedia = lightboxMedia.allFiles ? 
                                                        lightboxMedia.allFiles[currentLightboxIndex] : 
                                                        lightboxMedia;
                                                    return (
                                                        <>
                                                            <div>æ–‡ä»¶å: {currentMedia.name || 'æœªçŸ¥'}</div>
                                                            <div>ç±»å‹: {currentMedia.type === 'image' ? 'å›¾ç‰‡' : currentMedia.type === 'video' ? 'è§†é¢‘' : 'æ–‡æœ¬'}</div>
                                                            {currentMedia.size && (
                                                                <div>å¤§å°: {(currentMedia.size / 1024 / 1024).toFixed(2)} MB</div>
                                                            )}
                                                        </>
                                                    );
                                                })()}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                        </div>
                        
                        {/* å­˜å‚¨çŠ¶æ€æ˜¾ç¤º */}
                        <StorageStatusDisplay />
                    </div>
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>